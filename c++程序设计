位运算：
    1.按位与“&”：相同为1，不同为0.
      通常用来将某变量中的某些位清0且同时保留其他位不变。也可用来获取某些变量中的某一位。
      例如，如果需要将int型变量n的低8位全置成0，而其余位不变，则可以执行：
      n=n&0xffffff00; 也可写成： n&=0xffffff00;
      若n是short类型的，则只需执行： n&=0xff00;
      如果想判断一个int型变量n的第7位（从右往左）是否是1，只需看表达式“n&0x80”的值是否等于"0x80";    0x80=1000 0000(二进制)
      
    2.按位或“|”:其功能是参与运算的两数各对应的二进位相或。只要对应的二个二进位有一个为1时，结果位就为1。
      按位或运算通常用来将某些位置1且保其余位不变。
      
    3.按位异或“^”：相同为0，不同为1；  
      按位异或通常用来将某些变量中的某些为取反，且保留其他位不变。
      如果a^b=c,那么就有c^b=a以及c^a=b。
      异或运算还能实现不通过临时变量，就能交换两个变量的值。
      例如： 
          int a=5,b=7;
          a=a^b;
          b=b^a;
          a=a^b;
          此时：a=7,b=5;
          
    4.按位非“~”：单目运算符，功能是将二进制中0变1，1变0（取反）。
    
    5.左移运算符“<<”：
        表达式：
        a<<b 的值是：将a各二进制位全部左移b位后得到的值。左移时，高位丢弃，低位补0。a的值不因运算而改变。
        实际上，左移1位，就相当是乘以2，左移n位，就相当于是乘以2的n次方。但左移操作比乘法操作快得多。
      
     6.右移运算符“>>”
        表达式：
        a>>b
        的值是：将a各二进制位全部右移b位得到的值。右移时，移除最右边的位就被丢弃。a的值不因运算而改变。
        对于有符号数，如long,int,short,char类型变量，在右移时，符号位（即最高位）将一起移动，并且大多数C/C++编译器规定，如果原
        符号位为1，则右移时高位就补1，原符号位为0，则补0。
         实际上，左移1位，就相当是乘以2，左移n位，就相当于是乘以2的n次方。并且结果往小里取整。

引用：
     类型名 & 引用名 =某变量名； 
     int n=4;
     int &r=n;//r引用了n，r的类型时 int &；
     某个变量的引用，等价于这个变量，相当于该变量的一个别名。 如上式，n的值改变时，r的值也随之改变，反之亦然。
     定义引用时一定要将其初始化成引用某个变量。初始化后，它就一直引用该变量，不会再引用别的变量了。  引用只能引用变量，不能引用常量和表达式。
     如：
         double a=4,b=5;
         double &r1=a;
         double & r2=r1;//r2也引用a
         r2=10;
         cout<<a<<endl;//输出10
         r1=b;
         cout<<a<<endl;//输出5
     定义引用时，前面加const关键字，即为“常引用”，不能通过常引用去修改其引用的内容：
     const T &和T &是不同的类型！！！
     T & 类型的引用或T类型的变量可以用来初始化const T & 类型的引用。
     const T 类型的常变量和const T & 类型的引用则不能用来初始化T &类型的引用，除非进行强制类型转换。

内联函数：
    函数调用是有时间开销的。为了减少函数调用的开销，c++引入了内联函数机制。编译器处理对内联函数的调用语句是，是将整个函数的代码插入到调用的语句出，
    而不会产生调用函数的语句。
    在函数定义前加“inline”关键字，即可定义内联函数：
        inline int Max(int a,int b)
        {
            if(a>b)return a;
            return b;
        }
    内联函数通常是一些很小的函数。
        
函数重载：
    一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数重载。
    函数重载使得函数命名变得简单。
    编译器根据调用语句中的实参的个数和类型判断应该调用哪个函数。
    
函数的缺省参数：
    c++中，定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调用函数时，若相应位置不写参数，参数就时缺省值。
    如：
    void func(int x1,int x2=2,int x3=3);
    func(10);//等效于func（10,2,3）
    func(10,8);//等效于func(10,8,3)
    func(10,,8);//不行，只能最右边的连续若干个参数缺省。
 
 
面向对象：
    如何构建类：
        写一个程序，输入矩形的宽和高，输入面积和周长。
           ·矩形的属性-宽和高
             ·两个变量，分别代表宽和高。
           ·对矩形的操作
             ·设置宽和高
             ·计算面积
             ·计算周长
        矩形类
        int w;     -- 成员变量  ---
        int h;     --    
                               ---   类的成员    
        Area();     --            
        perimeter();--成员函数  ---
        lnit(...);  --
        
     对象的内存分配   
       ·对象的内存空间
         ·对象的大小=所有成员变量的大小之和
       ·每个对象各有自己的存储空间
         ·一个对象的某个成员变量被改变，不会影响到其他变量。
     
     对象间的运算
       ·对象之间可以用‘=’进行赋值
       ·不能用‘==’，‘！=’，‘>’,‘<’,‘>=’,‘<=’进行比较
           ·除非这些运算符经过了“重载”
           
     *访问类的成员变量和成员函数*
       ·用法1：对象名.成员名
           class CRectangle(){
              int w.....
              .....
              int lnit(){...}
              ...
           
           }
           int main(){
               CRectangle r1,r2;
               r1.w=5;
               r2.lnit(3,4);
           }
    
      ·用法2：指针->成员名
          CRectangle r1,r2;
          CRectangle *p1=&r1;
          CRectangle *p2=&r2;
          p1->w=5;
          p2->lnit(3,4);//lnit作用在p2指向的对象上

      ·用法3：引用名.成员名
          CRectangle r2;
          CRectangle &rr=r2;
          rr.w=5;
          rr.lnit(3,4);
       
      ·另一种输出结果的方式
          void PrintRectangle(CRectangle & r){
              cout<<r.Area()<<","<<r.Perimeter();
          }
          CRectangle r3;
          r3.lnit(3,4);
          PrintRectangle(r3);
        
     ·类的成员函数的另一种写法
         ·成员函数和类的定义分开写
         class CRectangle
         {
             public:
                int w,h;
                int Area();//成员函数仅在此处声明
                int Perimeter();
                void lnit(int w-,int h_);
         };
         int CRectangle::Area(){
              return w*h;
          }
         int CRectangle::Perimeter(){
             return 2*(w+h);
         }
         void CRectangle::lnit(int w_,int h_){
             w=w_;h=h_;
         }
         调用通过：对象/对象的指针/对象的引用


类成员的可访问范围
    ·关键字--类成员可被访问的范围
        ·private:指定私有成员，只能在成员函数内被访问
        ·public:指定公有成员，可以在任何地方被访问
        ·protected:指定保护成员
    ·三种关键字出现的次数和先后次序都没有限制
     
    ·缺省（没有标记关键字的）为私有成员
    
    ·设置私有成员的目的
        ·强制对成员变量的访问一定要通过成员函数进行
    ·设置私有成员的机制--隐藏

·内联成员函数
      ·内联成员函数
        ·inline+成员函数
        ·整个函数体出现在类定义内部
        
·成员函数的重载及参数缺省
      ·重载成员函数
      ·成员函数--带缺省参数
      
      ·使用缺省参数要注意避免有函数重载是的二义性（会使编译器分不清要调用哪个函数）


·构造函数
      ·成员函数的一种
        ·名字与类名相同，可以有参数，不能有返回值（void也不行）
       *·作用是对对象进行初始化，如给成员变量赋初值
        ·如果定义类时没写构造函数，则编译器会自动生成一个默认的无参数的构造函数
          ·默认构造函数无参数，不做任何操作。
       
        ·如果定义了构造函数，则编译器不生成默认的无参数的构造函数
        ·对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数
        ·一个类可以有多个构造函数
        
       ·为什么需要构造函数：
       （1）构造函数执行必要的初始化工作，有了构造函数，就不必专门再写初始化函数，也不用担心忘记调用初始化函数。
       （2）有时对象没被初始化就被使用，会导致程序出错！
      
    
 ·复制构造函数
       ·只有一个参数，即对同类对象的引用。
       ·形如 X::X(X&)或X:X(const X &),二者选一，后者能以常量对象作为参数
       ·如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能。
       ·如果定义的自己的复制构造函数，则默认的复制构造函数不存在。自己定义的复制构造函数不止能完成复制功能，还能在里面设置一些其他的工作让复制构造函数
       去做。
       ·不允许有形如X:X(X)的复制构造函数。
       
     ·复制构造函数起作用的三种情况
       （1）当用一个对象去初始化同类的另一个对象时。
           complex c2(c1);
           complex c2=c1; //初始化语句，非赋值语句；若将complex去掉，则是赋值语句。
          
       （2）如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用。
            class A{
               public:
               A(){};
               A(A&a){
                   cout<<"Copy constructor called"<<endl;
               }
            };
             void Func(A a1){}
             int main(){
                 A a2;
                 Func(a2);    //此时a1被复制构造函数初始化，参数是a2。
                 return 0;
             }
             
        （3）如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用：
    
    
  ·类型转换构造函数
      ·目的
        ·实现类型的自动转换
        
      ·特点
        ·只有一个参数
        ·不是复制构造函数
        
      ·编译系统会自动调用->转换构造函数
       ->建立一个临时对象/临时变量。
       
 ·析构函数
      ·名字与类名相同
      ·在前面加‘~’
      ·没有参数和返回值
      ·一个类最多只有一个析构函数
      
      ·对象消亡时->自动被调用
        ·在对象消亡前作善后工作
          ·释放分配的空间等
          
      ·定义类时没写析构函数，则编译器生成缺省析构函数
        ·不涉及释放用户申请的内存释放等清理工作
      ·定义了析构函数，则编译器不生成缺省析构函数
      
      ·析构函数和数组
        ·对象数组生命期结束时，对象数组的每个元素的析构函数都会被调用。
        
      ·析构函数和运算符delete
        ·delete运算导致析造函数调用 
        
   
·静态成员：
      在说明前面加了static关键字的成员。
      
      ·普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享。
        sizeof运算符不会计算静态成员变量。
        
      ·普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享。
      
      ·普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用与某个对象。
      
      ·因此静态成员不需要通过对象就能访问。
      
      ·如何访问静态成员
      
        （1）类名::成员名
              CRectangle::PrintTotal();
         (2) 对象名.成员名
              CRectangle r;r.PrintTotal();
         (3) 指针->成员名
              CRectangle*p=&r;p->PrintTotal();
        （4）引用.成员名
              CRectangle &ref=r;int n=ref.nTotalNumBer;
       
       ·基本概念
         ·静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在。
         ·静态成员函数本质上是全局函数。
         ·设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。
         
       ·注意：在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。
       
      
    ·成员对象和封闭类
       ·成员对象：一个类的成员变量是另一个类的对象
       ·包含成员对象的类叫封闭类
       
    ·生成封闭对象的语句，要明确“对象中的成员对象”如何初始化。
    
    ·封闭类构造函数的初始化列表
        ·定义封闭类的构造函数时，添加列表：
        类名::构造函数（参数表):成员变量1（参数表），成员变量2（参数表），.....
        {
         ...
        }
    
    ·成员对象初始化列表中的参数
        ·任意复杂的表达式
        ·函数/变量/表达式中的函数，变量有定义
      
    ·调用顺序
        ·当封闭类对象生成时，
            ·s1:执行所有成员对象的构造函数
            ·s2:执行封闭类的构造函数
        ·成员对象的构造函数调用顺序
            ·和成员对象在类中的说明顺序一致
            ·与在成员初始化列表中出现的顺序无关   
        ·当封闭类的对象消亡是，
            ·s1：先执行封闭类的析构函数
            ·s2：执行成员对象的析构函数
        ·析构函数顺序和构造函数的调用顺序相反
                
                
       
  ·友元（friend）
        ·友元函数
          ·一个类的友元函数可以访问该类的私有成员
          ·可以将一个类的成员函数（包括构造，析构函数）定义成另一个类的友元
          
        ·友元类
          ·A是B的友元类->A的成员函数可以访问B的私有成员
         （友元之间的关系不能传递，不能继承）
        
        
   this指针
         ·其作用就是指向成员函数所作用的对象
         
         ·静态成员函数中不能使用this指针！
         ·因为静态成员函数并不具体作用与某个对象！
         ·因此，静态成员函数的真实的参数的个数，就是程序中写出的参数个数！
         
         
  ·常量对象，常量成员函数和常引用
        ·常量对象
            ·如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加const关键字。
            
        ·常量成员函数
            ·在类的成员函数说明后面可以加const关键字，则该成员函数成为常量成员函数。
            ·常量成员函数执行期间不应修改其所作用的对象。因此，在常量成员函数中不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成
            员函数（静态成员函数除外）。
          
        ·常量成员函数的重载
            ·两个成员函数，名字和参数表都一样，但一个是const，一个不是，算重载。
            
        ·常引用
            ·引用前面可以加const关键字，成为常引用。不能通过常引用，修改其引用的变量。
          
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
    
    
    
    
    







