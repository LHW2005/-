   1.     1314 【例3.6】过河卒（Noip2002）
     #include<iostream>
     using namespace std;
     int n, m, cx, cy;
     long long f[40][40], g[40][40];  //防止数据太大，最好使用long整型的数
     int main()
        {
        cin>>n>>m>>cx>>cy;
        f[0][0]=1;
    
        g[cx][cy]=1;  //将马所在的位置置成1
        //以下是将马能攻击到的地方标记
        if(cx-1>=0&&cy-2>=0)g[cx-1][cy-2]=1;
        if(cx+1<=n&&cy-2>=0)g[cx+1][cy-2]=1;
        if(cx-2>=0&&cy-1>=0)g[cx-2][cy-1]=1;
        if(cx+2<=n&&cy-1>=0)g[cx+2][cy-1]=1;
        if(cx-2>=0&&cy+1<=m)g[cx-2][cy+1]=1;
        if(cx+2<=n&&cy+1<=m)g[cx+2][cy+1]=1;
        if(cx-1>=0&&cy+2<=m)g[cx-1][cy+2]=1;
        if(cx+1<=n&&cy+2<=m)g[cx+1][cy+2]=1;
        
        //将卒的可行走的地方标记
        for(int i=1; i<=n; i++)
          if(!g[i][0])f[i][0]=f[i-1][0];
        for(int j=1; j<=m; j++)
          if(!g[0][j])f[0][j]=f[0][j-1];
          
        //计算路径数量
        for(int i=1; i<=n; i++)
            for(int j=1; j<=m; j++)
            {
                //是否是可行走路径
                if(g[i][j])f[i][j]=0;     //若不是则为0 
                if(!g[i][j])f[i][j]=f[i][j-1]+f[i-1][j];  //若是则将路径数增加
            }
            
        cout<<f[n][m];
        return 0;
}


   2.    1315：【例4.5】集合的划分
   
    #include<iostream>
    #include<cstring>
    using namespace std;
    long long s(int n,int k) 
    {
        if((n<k)||(k==0)) return 0;    
        if((k==1)||(k==n)) return 1;
        return s(n-1,k-1)+k*s(n-1,k);    //如果an是k的一个子集，那么将 a1,a2,a3--an-1划分为k-1个子集，数量有s(n-1,k-1)个
                                         //如果an不是k的一个子集，那么an必然与其它数构成子集，则可以a1,a2...an划为k个子集，此时有s(n-1,k)种可能
                                         然后将an加入k个子集中的任意一个，所以有k*s(n-1,k)种可能。
                                         
    }
    int main()
    {
        int n,k;
        cin>>n>>k;
        cout<<s(n,k)<<endl;
        return 0;
    }
    
    
    3，   1203：扩充匹配问题
       #include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib》
using namespace std；
int main()
{
    string a;
    while(cin>>a)    //如果有输入，将会一直进行
    {
        int m=0;      //代表左括号的个数
        char b[102];  //用于存储？$‘ ’
        int c[102];   //用于存下左括号的下标值
        int l=a.size();
        for(int i=0;i<l;i++)
        {
            if(a[i]=='(')
            {
                c[m]=i;
                m++;   //左括号的个数＋1
                b[i]=' ';
            }
           else if(a[i]==')'&&m<=0)   //前面没有左括号的时候
            {
               b[i]='?';
                //cout<<i;
            }
           else if(a[i]==')'&&m!=0){   //前面有左括号
                m--;
                b[i]=' ';
           }
           else
               b[i]=' ';
        }
        for(int i=0;i<m;i++)
            b[c[i]]='$';
        b[l]='\0';
        cout<<a<<endl;
        cout<<b<<endl;
    }
    return 0;
}


 4.   1208：2的幂次方表示
 
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #define N 1000010
    using namespace std;
    void calculate(int n,int step)
    {
        if(n==0)        
            return;
        calculate(n/2,step+1);     
        if(n%2)
       {
            if(n/2)
                cout<<"+";
            if(step==1)
                cout<<"2";
            else
            {
                cout<<"2(";
                if(step==0)
                    cout<<"0";
                else
                    calculate(step,0);
                 cout<<")";
            }
        }
    }
    int main()
    {
        int n;
        cin>>n;
        calculate(n,0);
        cout<<endl;
        return 0;
    }
    
    
5.   1211判断元素是否存在
    #include<bits/stdc++.h>
    using namespace std;
    bool f(int k,int x)
    {
        if(k==x)
            return true;
        if(k>x)
           return false;
        return f(3*k+1,x)||f(2*k+1,x); //当看k<x时，不断增大k值，直到与x相等。 
    }
    int main()
    {
        int k,x;
        scanf("%d,%d",&k,&x);
        if(f(k,x))
            cout<<"YES"<<endl;
        else
            cout<<"NO"<<endl;
        return 0;
    }
    
    
    
  6.   1212：LETTERS
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #define N 30
    using namespace std;
    int r,s;
    char a[N][N];
    int vis[N][N];
    int num[26];
    int dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};//走的方式（向前，向后，向左，向右） 
    int maxx=0;
    void dfs(int x,int y,int step)//最多能走过的不同的字母的个数 
    {
        if(maxx<step)//更新最大值 
            maxx=step;
        for(int i=0;i<4;i++) 
        {
            int nx=x+dir[i][0];//走法（前后） 
            int ny=y+dir[i][1];//走法（左右） 
            if(nx>=0&&nx<r&&ny>=0&&ny<s&&vis[nx][ny]==0&&num[a[nx][ny]-'A']==0)//判断是否是走过的字母 
            {
                vis[nx][ny]=1;     
                num[a[nx][ny]-'A']=1;//将此字母做好标记 
                dfs(nx,ny,step+1);//走下一步 
                vis[nx][ny]=0; 
                num[a[nx][ny]-'A']=0; //重置数据，准备开始下一轮循环 
            }
        }
    }
    int main()
    {
        cin>>r>>s;
        for(int i=0;i<r;i++)
            for(int j=0;j<s;j++)
                cin>>a[i][j];
        num[a[0][0]-'A']=1;
        vis[0][0]=1; //将初始值标记 
        dfs(0,0,1);
        cout<<maxx<<endl;
        return 0;
}

     7.   1216：红与黑
     #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #define N 1001
    using namespace std;
    int m,n;
    char ch;
    int maps[N][N];
    int vis[N][N];
    int dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};//走的方式（向前，向后，向左，向右） 
    int cnt;
    void dfs(int x,int y)//能到达的最多瓷砖数 
    {
        for(int i=0;i<4;i++)//循环选出下一步的走法 
        {
            int nx=x+dir[i][0];
            int ny=y+dir[i][1];//读入走法 
            if(nx>=1&&ny>=1&&nx<=n&&ny<=m&&vis[nx][ny]==0&&maps[nx][ny]==1)//判断判断走法是否满足边界值 
            {
                vis[nx][ny]=1;//标记这块瓷砖 
                cnt++;//更新瓷砖数量 
                dfs(nx,ny);//开始下一步 
            }
        }
    }
    int main()
    {
        while(scanf("%d%d",&m,&n)!=EOF&&m&&n)//读入数据 
        {
            int x,y;
            cnt=1;
            memset(vis,0,sizeof(vis));
            memset(maps,0,sizeof(maps)); //将所有标记清空 
 
            for(int i=1;i<=n;i++)
                for(int j=1;j<=m;j++)//循环读入数据 
                {
                    cin>>ch;
                    if(ch=='@')
                    {
                        x=i;
                        y=j;
                        maps[i][j]=1;
                    }
                    if(ch=='.')
                        maps[i][j]=1; 
                    if(ch=='#')
                        maps[i][j]=0;//将所有黑瓷砖标记为1（包括初始位置），红瓷砖记为0 
                }
            vis[x][y]=1;
            dfs(x,y);
            cout<<cnt<<endl;
        }
        return 0;
    }
    
    
    8.   1217：棋盘问题
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #define N 10
    using namespace std;
    int n,k;
    char maps[N][N];
    int vis[N];
    int dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};//走的方式（向前，向后，向左，向右） 
    int cnt;
    void dfs(int x,int y)//摆放的方案数量 
    {
        if(y==k)//判断棋盘位置与数量是否相等（相等的话只有一种走法） 
        {
            cnt++;
            return;
        }
        for(int i=x;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(maps[i][j]=='#'&&vis[j])//判断是否在棋盘上以及此处是否了东西 
                {
                    vis[j]=0;
                    dfs(i+1,y+1);
                    vis[j]=1;
                }
         return;
    }
    int main()
    {
        while(scanf("%d%d",&n,&k)!=EOF)//读入数据 
        {
            if(n==-1&&k==-1)
                break;
 
            memset(vis,1,sizeof(vis));//重置其值为1，用来标记棋盘上是否有子 
 
            for(int i=1;i<=n;i++)
                for(int j=1;j<=n;j++)
                    cin>>maps[i][j];
 
            cnt=0;
            dfs(1,0);
            cout<<cnt<<endl;
        }
        return 0;
    }
   
     10.   1221：分成互质组
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<algorithm>
    #define N 20
    using namespace std;
    int n;
    int a[N];
    int cnt=99999;
    long long vis[N];
    long long gcd(long long a,long long b)//是否互指 
    {
        if(b==0)
            return a;
        return
            gcd(b,a%b);
    }
    void dfs(int k,int step)//完成分组 
    {
        if(step==n+1)
    {
            if(k<cnt)
                cnt=k;
             return;
    }
    for(int i=1;i<=k;i++)
        if(gcd(vis[i],a[step])==1)//判断是否互质 
        {
            vis[i]*=a[step];
            dfs(k,step+1);
            vis[i]/=a[step];//完成记录 
        }
        vis[k+1]*=a[step];
        dfs(k+1,step+1);
        vis[k+1]/=a[step];//为下次准备 
    }
        int main()
        {
        int temp;
         cin>>n;
           for(int i=1;i<=n;i++)//读入数据 
        { 
            cin>>a[i];
            vis[i]=1;
    }
    sort(a+1,a+1+n);
    dfs(1,1);
    cout<<cnt<<endl;
    return 0;
}
    
    
 11.   1222：放苹果
    #include<iostream>
    using namespace std;
    int f(int m,int n){
        if(n>m)
	    return f(m,m);
        if(m==0)
            return 1;
        if(n==0)
            return 0;
        return f(m,n-1)+f(m-n,n);//摆放的可能性有：空着盘子的 +不空盘中的。空着盘子的每次循环盘子数减一，表示少一个盘子的方法，少两个的方法....，
	不空的循环时: 剪掉盘数，表示每盘放一个后的可能性. 
    }
    int main(){
	    int t,m,n;
	    cin>>t;
	    while(t--){
		    cin>>m>>n;
		    cout<<f(m,n)<<endl;
	    }
	    return 0;
    }

  
      12.  1325：循环比赛日程表
    #include<bits/stdc++.h>
    using namespace std;
    const int maxn=1025;
    int m[maxn][maxn];//记录n名选手的循环比赛表
    int main()
    {
        int m1;
        cin>>m1;
        int n=1<<m1;//相当于2^m
        int k=1,half=1;//half相当于方阵现在的大小
        m[0][0]=1;
        while(k<=m1)
        {
            for(int i=0;i<half;i++)//构造右上角
            {
                for(int j=0;j<half;j++)
                {
                    m[i][j+half]=m[i][j]+half;
                }
            }
            for(int i=0;i<half;i++)//对称交换构造下半部分方阵
            {
                for(int j=0;j<half;j++)
                {
                    m[i+half][j]=m[i][j+half];//左下
                    m[i+half][j+half]=m[i][j];//右下
                }
            }
            half*=2;
            k++;
 
        }
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(j)
                    cout<<" ";
                cout<<m[i][j];
            }
            cout<<endl;
        }
        return 0;
    }
    
     13.   1326：【例7.5】取余运算(mod)
    #include<bits/stdc++.h>
    using namespace std;
    int b,p,k;
    int calculate(int p)
    {
        int temp;
 
        if(p==0)//b^0%k=1
            return 1;
            cout<<p<<endl;
        temp=calculate(p/2)%k;//将p除于2，降低数值。 
        temp=(temp*temp)%k;//b^p%k=(b^(p/2)^2)%k
        if(p%2==1)
            temp=(temp*b)%k; 
        return temp;
     }
    int main()
    {
        cin>>b>>p>>k;
        int temp=b;
        b%=k;
        cout<<temp<<"^"<<p<<" mod "<<k<<"="<<calculate(p)<<endl;
        return 0;
 }
 
 
   14.   1328：【例7.7】光荣的梦想
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<algorithm>
    #include<string>
    #define INF 999999999
    #define N 1000001
    #define MOD 1000000007
    using namespace std;
    int n;
    int a[N],b[N];
    long long ans=0;
    void msort(int left,int right)
    {
        int mid=(left+right)/2;
        if(left>=right)
            return ;
        msort(left,mid);
        msort(mid+1,right);//二分算法查找最小值 
 
        int i=left,j=mid+1,n=mid,m=right,k=0;
        while(i<=n&&j<=m)
            if(a[i]>a[j])
            {
                ans+=n-i+1;
                b[k++]=a[j++];
            }
            else
                b[k++]=a[i++];
        while(i<=n)
            b[k++]=a[i++];
        while(j<=m)
            b[k++]=a[j++]; 
        for(i=0;i<k;i++)
            a[left+i]=b[i];
    }
    int main()
    {
        cin>>n;
        for(int i=1;i<=n;i++)
            cin>>a[i];
        msort(1,n);
        cout<<ans<<endl;
        return 0;
    }
 
 
     15.   1234：2011
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<algorithm>
    #include<string>
    #define INF 999999999
    #define N 500
    #define MOD 1000000007
    using namespace std;
    char a[N];
    int main()
    {
        int k;
        cin>>k;
        while(k--)
        {
            cin>>a;
            int len=strlen(a);
            int B=0,C=2011;
            int i;
 
            for(i=len-4;i<len;i++)
                if(i>=0)
                    B=B*10+a[i]-'0';
            
            i=1;
            do{
                if(i*2<=B)
                {
                    i*=2;
                    C=(C*C)%10000;
                }
            }while(i*2<=B);
            for(;i<B;i++)
                C=(C*2011)%10000;
            cout<<C<<endl;
        }
        return 0;
    }
    
   
      16.   1238：一元三次方程求解
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #define INF 999999999
    #define N 50001
    #define MOD 1000000007
    #define E 1e-5
    using namespace std;
    double a,b,c,d;
    double calculate(double x)//方程的计算 
    {
        double ans=0;
        double y=1;
     
        for(int i=1;i<=3;i++)
            y*=x;
        y*=a;
        ans+=y;
     
        y=1;
        for(int i=1;i<=2;i++)
            y*=x;
        y*=b;
        ans+=y;
     
        y=1;
        y*=x;
        y*=c;
        ans+=y;
     
        ans+=d;
        return ans;
    }
    int main()
    {
        double x=-100,x1,x2,x3;
     
        cin>>a>>b>>c>>d;
        while(x-100<=E)//第一个实根 
        {
            if(fabs(calculate(x))<=E)
                break;
            x+=0.01;
        }
        x1=x;
     
        x+=0.01;
        while(x-100<=E)//第二个实根 
        {
            if(fabs(calculate(x))<=E)
                break;
            x+=0.01;
        }
        x2=x;
     
        x+=0.01;
        while(x-100<=E)//第三个实根 
        {
            if(fabs(calculate(x))<E)
                break;
            x+=0.01;
        }
        x3=x;
        printf("%.2lf %.2lf %.2lf\n",x1,x2,x3);
        return 0;
    }
 
 
      17.  1239：统计数字
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<cmath>
    #include<string>
    #define INF 999999999
    #define N 1000001
    #define MOD 1000000007
    #define E 1e-5
    using namespace std;
    int a[N];
    void quicksort(int left,int right)
    {
        int i=left,j=right,mid=a[(left+right)/2];
        while(i<=j)
        {
            while(a[i]<mid)
                i++;
            while(a[j]>mid)
                j--;
            if(i<=j)
            {
                swap(a[i],a[j]);
                i++;
                j--;
            }
        }
        if(i<right)
            quicksort(i,right);
        if(left<j)
            quicksort(left,j);
    }
    int main()
    {
        int n;
        int cnt=1;
        cin>>n;
        for(int i=1;i<=n;i++)
            cin>>a[i];
        quicksort(1,n);
        while(cnt<=n)//当cnt不大于n时，开始循环 
        {
            int s=a[cnt],k=cnt; 
            while(s==a[cnt])//每找到一个相同的数(包括自己本身)，cnt+1 
                cnt++;
            cout<<a[cnt-1]<<" "<<cnt-k<<endl;//用cnt-k来表示找到了多少相同的数 
        }
        return 0;
    }
    
    
  18.   1241：二分法求函数的零点
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #define INF 999999999
    #define N 1000001
    #define MOD 1000000007
    #define E 1e-7
    using namespace std;
    double calculate(double x)//计算函数的值 
    {
        return x*x*x*x*x-15*x*x*x*x+85*x*x*x-225*x*x+274*x-121;
    }
    double myabs(double x){//计算数的绝对值 
        if(x<0)return -x;
        return x;
    }
    int main()
    {
        double left=1.5,right=2.4;
        while(left+E<right)
        {
            double mid=(left+right)/2.0;
            if(calculate(mid)>0)
                left=mid;
            else right=mid;
        }
        if(calculate(left)==0)
            printf("%.6lf\n",left);
        else
            printf("%.6lf\n",left);
        return 0;
    }


     19.   1245：不重复地输出数
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #define INF 999999999
    #define N 1000001
    #define MOD 1000000007
    #define E 1e-3
    using namespace std;
    int a[N];
    int main()
    {
        int n;
        cin>>n;
        for(int i=1;i<=n;i++)//读入数据 
            cin>>a[i];
        sort(a+1,a+1+n);//从小到大排序 
        cout<<a[1];
        for(int i=2;i<=n;i++)    
            if(a[i]!=a[i-1])//判断前数是否相等,确保重复的数只输一次 
                cout<<" "<<a[i];
        cout<<endl;
        return 0;
    }
    
    
    20.  1247：河中跳房子
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #define INF 999999999
    #define N 1000001
    #define MOD 1000000007
    #define E 1e-12
    using namespace std;
    int l,n,m;
    int a[N];
    int judge(int x)
    {
        int i,dis=0,num=0;
        for(int i=1;i<=n;i++)
            if(a[i]-dis<x)
                num++;
            else
                dis=a[i];
        if(l-dis<x)
            num++;
        return num<=m;
    }
    int main()
    {
        int left,right,mid;
        cin>>l>>n>>m;
        for(int i=1;i<=n;i++)
            cin>>a[i];
        left=0;
        right=l;
        while(left+1<right)
        {
            mid=(left+right)/2;
            if(judge(mid))
                left=mid;
            else
                right=mid;
        }
        cout<<left<<endl;
        return 0;
    }
    
    
21.  1261：【例9.5】城市交通路网

    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<algorithm>
    #define maxn 100
    #define inf 1e9
    int a[maxn][maxn];
    int f[maxn];
    int pre[maxn];
    using namespace std;
    int main()
    {
        int n;
      scanf("%d",&n);
        memset(a,0,sizeof(a));
        memset(pre,0,sizeof(pre));//将两个数组清零 
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)//读入数据 
          scanf("%d",&a[i][j]);
            for(int i=1;i<=maxn;i++)//如入路程 
                f[i]=inf;
                f[n]=0;
        for(int i=n-1;i>=1;i--)
            for(int j=i+1;j<=n;j++)
        {
            if(a[i][j]>0&&f[j]!=inf&&f[i]>a[i][j]+f[j])//判断是否是最短路径 
     
                {f[i]=f[j]+a[i][j];
                pre[i]=j;    //求出最少的钱 
     
        }
        }
        printf("minlong=%d\n",f[1]);
        int k=1;
        while(k!=0)
        {
            printf("%d ",k);
            k=pre[k];
     
                }
                printf("\n");
    }
   
   22.   1263：【例9.7】友好城市
    #include<iostream>
    #include<cstdio>
    #include<algorithm>
    #include<iomanip>
    using namespace std;
    struct node//表示走法 
    {
        int east,west;
    };
    node a[5100];
    int d[5100];
    bool cmp(node c,node d)//记录航道数 
    {
        return c.east<d.east;
    }
    int main()
    {
        int n;
        scanf("%d",&n);
        int i,x,len=1;
        for(i=1;i<=n;i++)
            scanf("%d%d",&a[i].east,&a[i].west);
        d[1]=a[1].west;
        sort(a+1,a+n+1,cmp);//重新排列友好城市，按cmp(从小到大)排 
        for(i=2;i<=n;i++)
        {
            x=upper_bound(d+1,d+len+1,a[i].west)-d;
            d[x]=a[i].west;
            if(x>len)len++;
        }
        cout<<len<<endl;
        return 0;
    }

    
    
    
    
    
    





















	
      


	
         
