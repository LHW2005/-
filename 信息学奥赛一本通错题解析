   1.     1314 【例3.6】过河卒（Noip2002）
     #include<iostream>
     using namespace std;
     int n, m, cx, cy;
     long long f[40][40], g[40][40];  //防止数据太大，最好使用long整型的数
     int main()
        {
        cin>>n>>m>>cx>>cy;
        f[0][0]=1;
    
        g[cx][cy]=1;  //将马所在的位置置成1
        //以下是将马能攻击到的地方标记
        if(cx-1>=0&&cy-2>=0)g[cx-1][cy-2]=1;
        if(cx+1<=n&&cy-2>=0)g[cx+1][cy-2]=1;
        if(cx-2>=0&&cy-1>=0)g[cx-2][cy-1]=1;
        if(cx+2<=n&&cy-1>=0)g[cx+2][cy-1]=1;
        if(cx-2>=0&&cy+1<=m)g[cx-2][cy+1]=1;
        if(cx+2<=n&&cy+1<=m)g[cx+2][cy+1]=1;
        if(cx-1>=0&&cy+2<=m)g[cx-1][cy+2]=1;
        if(cx+1<=n&&cy+2<=m)g[cx+1][cy+2]=1;
        
        //将卒的可行走的地方标记
        for(int i=1; i<=n; i++)
          if(!g[i][0])f[i][0]=f[i-1][0];
        for(int j=1; j<=m; j++)
          if(!g[0][j])f[0][j]=f[0][j-1];
          
        //计算路径数量
        for(int i=1; i<=n; i++)
            for(int j=1; j<=m; j++)
            {
                //是否是可行走路径
                if(g[i][j])f[i][j]=0;     //若不是则为0 
                if(!g[i][j])f[i][j]=f[i][j-1]+f[i-1][j];  //若是则将路径数增加
            }
            
        cout<<f[n][m];
        return 0;
}


   2.    1315：【例4.5】集合的划分
   
    #include<iostream>
    #include<cstring>
    using namespace std;
    long long s(int n,int k) 
    {
        if((n<k)||(k==0)) return 0;    
        if((k==1)||(k==n)) return 1;
        return s(n-1,k-1)+k*s(n-1,k);    //如果an是k的一个子集，那么将 a1,a2,a3--an-1划分为k-1个子集，数量有s(n-1,k-1)个
                                         //如果an不是k的一个子集，那么an必然与其它数构成子集，则可以a1,a2...an划为k个子集，此时有s(n-1,k)种可能
                                         然后将an加入k个子集中的任意一个，所以有k*s(n-1,k)种可能。
                                         
    }
    int main()
    {
        int n,k;
        cin>>n>>k;
        cout<<s(n,k)<<endl;
        return 0;
    }
    
    
    3，   1203：扩充匹配问题
       #include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib》
using namespace std；
int main()
{
    string a;
    while(cin>>a)    //如果有输入，将会一直进行
    {
        int m=0;      //代表左括号的个数
        char b[102];  //用于存储？$‘ ’
        int c[102];   //用于存下左括号的下标值
        int l=a.size();
        for(int i=0;i<l;i++)
        {
            if(a[i]=='(')
            {
                c[m]=i;
                m++;   //左括号的个数＋1
                b[i]=' ';
            }
           else if(a[i]==')'&&m<=0)   //前面没有左括号的时候
            {
               b[i]='?';
                //cout<<i;
            }
           else if(a[i]==')'&&m!=0){   //前面有左括号
                m--;
                b[i]=' ';
           }
           else
               b[i]=' ';
        }
        for(int i=0;i<m;i++)
            b[c[i]]='$';
        b[l]='\0';
        cout<<a<<endl;
        cout<<b<<endl;
    }
    return 0;
}


 4.   1208：2的幂次方表示
 
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #define N 1000010
    using namespace std;
    void calculate(int n,int step)
    {
        if(n==0)        
            return;
        calculate(n/2,step+1);     
        if(n%2)
       {
            if(n/2)
                cout<<"+";
            if(step==1)
                cout<<"2";
            else
            {
                cout<<"2(";
                if(step==0)
                    cout<<"0";
                else
                    calculate(step,0);
                 cout<<")";
            }
        }
    }
    int main()
    {
        int n;
        cin>>n;
        calculate(n,0);
        cout<<endl;
        return 0;
    }
    
    
5.   1211判断元素是否存在
    #include<bits/stdc++.h>
    using namespace std;
    bool f(int k,int x)
    {
        if(k==x)
            return true;
        if(k>x)
           return false;
        return f(3*k+1,x)||f(2*k+1,x); //当看k<x时，不断增大k值，直到与x相等。 
    }
    int main()
    {
        int k,x;
        scanf("%d,%d",&k,&x);
        if(f(k,x))
            cout<<"YES"<<endl;
        else
            cout<<"NO"<<endl;
        return 0;
    }
    
    
    
  6.   1212：LETTERS
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #define N 30
    using namespace std;
    int r,s;
    char a[N][N];
    int vis[N][N];
    int num[26];
    int dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};//走的方式（向前，向后，向左，向右） 
    int maxx=0;
    void dfs(int x,int y,int step)//最多能走过的不同的字母的个数 
    {
        if(maxx<step)//更新最大值 
            maxx=step;
        for(int i=0;i<4;i++) 
        {
            int nx=x+dir[i][0];//走法（前后） 
            int ny=y+dir[i][1];//走法（左右） 
            if(nx>=0&&nx<r&&ny>=0&&ny<s&&vis[nx][ny]==0&&num[a[nx][ny]-'A']==0)//判断是否是走过的字母 
            {
                vis[nx][ny]=1;     
                num[a[nx][ny]-'A']=1;//将此字母做好标记 
                dfs(nx,ny,step+1);//走下一步 
                vis[nx][ny]=0; 
                num[a[nx][ny]-'A']=0; //重置数据，准备开始下一轮循环 
            }
        }
    }
    int main()
    {
        cin>>r>>s;
        for(int i=0;i<r;i++)
            for(int j=0;j<s;j++)
                cin>>a[i][j];
        num[a[0][0]-'A']=1;
        vis[0][0]=1; //将初始值标记 
        dfs(0,0,1);
        cout<<maxx<<endl;
        return 0;
}

     7.   1216：红与黑
     #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #define N 1001
    using namespace std;
    int m,n;
    char ch;
    int maps[N][N];
    int vis[N][N];
    int dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};//走的方式（向前，向后，向左，向右） 
    int cnt;
    void dfs(int x,int y)//能到达的最多瓷砖数 
    {
        for(int i=0;i<4;i++)//循环选出下一步的走法 
        {
            int nx=x+dir[i][0];
            int ny=y+dir[i][1];//读入走法 
            if(nx>=1&&ny>=1&&nx<=n&&ny<=m&&vis[nx][ny]==0&&maps[nx][ny]==1)//判断判断走法是否满足边界值 
            {
                vis[nx][ny]=1;//标记这块瓷砖 
                cnt++;//更新瓷砖数量 
                dfs(nx,ny);//开始下一步 
            }
        }
    }
    int main()
    {
        while(scanf("%d%d",&m,&n)!=EOF&&m&&n)//读入数据 
        {
            int x,y;
            cnt=1;
            memset(vis,0,sizeof(vis));
            memset(maps,0,sizeof(maps)); //将所有标记清空 
 
            for(int i=1;i<=n;i++)
                for(int j=1;j<=m;j++)//循环读入数据 
                {
                    cin>>ch;
                    if(ch=='@')
                    {
                        x=i;
                        y=j;
                        maps[i][j]=1;
                    }
                    if(ch=='.')
                        maps[i][j]=1; 
                    if(ch=='#')
                        maps[i][j]=0;//将所有黑瓷砖标记为1（包括初始位置），红瓷砖记为0 
                }
            vis[x][y]=1;
            dfs(x,y);
            cout<<cnt<<endl;
        }
        return 0;
    }
    
    
    8.   1217：棋盘问题
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #define N 10
    using namespace std;
    int n,k;
    char maps[N][N];
    int vis[N];
    int dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};//走的方式（向前，向后，向左，向右） 
    int cnt;
    void dfs(int x,int y)//摆放的方案数量 
    {
        if(y==k)//判断棋盘位置与数量是否相等（相等的话只有一种走法） 
        {
            cnt++;
            return;
        }
        for(int i=x;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(maps[i][j]=='#'&&vis[j])//判断是否在棋盘上以及此处是否了东西 
                {
                    vis[j]=0;
                    dfs(i+1,y+1);
                    vis[j]=1;
                }
         return;
    }
    int main()
    {
        while(scanf("%d%d",&n,&k)!=EOF)//读入数据 
        {
            if(n==-1&&k==-1)
                break;
 
            memset(vis,1,sizeof(vis));//重置其值为1，用来标记棋盘上是否有子 
 
            for(int i=1;i<=n;i++)
                for(int j=1;j<=n;j++)
                    cin>>maps[i][j];
 
            cnt=0;
            dfs(1,0);
            cout<<cnt<<endl;
        }
        return 0;
    }
   
     10.   1221：分成互质组
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<algorithm>
    #define N 20
    using namespace std;
    int n;
    int a[N];
    int cnt=99999;
    long long vis[N];
    long long gcd(long long a,long long b)//是否互指 
    {
        if(b==0)
            return a;
        return
            gcd(b,a%b);
    }
    void dfs(int k,int step)//完成分组 
    {
        if(step==n+1)
    {
            if(k<cnt)
                cnt=k;
             return;
    }
    for(int i=1;i<=k;i++)
        if(gcd(vis[i],a[step])==1)//判断是否互质 
        {
            vis[i]*=a[step];
            dfs(k,step+1);
            vis[i]/=a[step];//完成记录 
        }
        vis[k+1]*=a[step];
        dfs(k+1,step+1);
        vis[k+1]/=a[step];//为下次准备 
    }
        int main()
        {
        int temp;
         cin>>n;
           for(int i=1;i<=n;i++)//读入数据 
        { 
            cin>>a[i];
            vis[i]=1;
    }
    sort(a+1,a+1+n);
    dfs(1,1);
    cout<<cnt<<endl;
    return 0;
}
    
    
 11.   1222：放苹果
    #include<iostream>
    using namespace std;
    int f(int m,int n){
        if(n>m)
	    return f(m,m);
        if(m==0)
            return 1;
        if(n==0)
            return 0;
        return f(m,n-1)+f(m-n,n);//摆放的可能性有：空着盘子的 +不空盘中的。空着盘子的每次循环盘子数减一，表示少一个盘子的方法，少两个的方法....，
	不空的循环时: 剪掉盘数，表示每盘放一个后的可能性. 
    }
    int main(){
	    int t,m,n;
	    cin>>t;
	    while(t--){
		    cin>>m>>n;
		    cout<<f(m,n)<<endl;
	    }
	    return 0;
    }

  
      12.  1325：循环比赛日程表
    #include<bits/stdc++.h>
    using namespace std;
    const int maxn=1025;
    int m[maxn][maxn];//记录n名选手的循环比赛表
    int main()
    {
        int m1;
        cin>>m1;
        int n=1<<m1;//相当于2^m
        int k=1,half=1;//half相当于方阵现在的大小
        m[0][0]=1;
        while(k<=m1)
        {
            for(int i=0;i<half;i++)//构造右上角
            {
                for(int j=0;j<half;j++)
                {
                    m[i][j+half]=m[i][j]+half;
                }
            }
            for(int i=0;i<half;i++)//对称交换构造下半部分方阵
            {
                for(int j=0;j<half;j++)
                {
                    m[i+half][j]=m[i][j+half];//左下
                    m[i+half][j+half]=m[i][j];//右下
                }
            }
            half*=2;
            k++;
 
        }
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(j)
                    cout<<" ";
                cout<<m[i][j];
            }
            cout<<endl;
        }
        return 0;
    }
    
     13.   1326：【例7.5】取余运算(mod)
    #include<bits/stdc++.h>
    using namespace std;
    int b,p,k;
    int calculate(int p)
    {
        int temp;
 
        if(p==0)//b^0%k=1
            return 1;
            cout<<p<<endl;
        temp=calculate(p/2)%k;//将p除于2，降低数值。 
        temp=(temp*temp)%k;//b^p%k=(b^(p/2)^2)%k
        if(p%2==1)
            temp=(temp*b)%k; 
        return temp;
     }
    int main()
    {
        cin>>b>>p>>k;
        int temp=b;
        b%=k;
        cout<<temp<<"^"<<p<<" mod "<<k<<"="<<calculate(p)<<endl;
        return 0;
 }
 
 
   14.   1328：【例7.7】光荣的梦想
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<algorithm>
    #include<string>
    #define INF 999999999
    #define N 1000001
    #define MOD 1000000007
    using namespace std;
    int n;
    int a[N],b[N];
    long long ans=0;
    void msort(int left,int right)
    {
        int mid=(left+right)/2;
        if(left>=right)
            return ;
        msort(left,mid);
        msort(mid+1,right);//二分算法查找最小值 
 
        int i=left,j=mid+1,n=mid,m=right,k=0;
        while(i<=n&&j<=m)
            if(a[i]>a[j])
            {
                ans+=n-i+1;
                b[k++]=a[j++];
            }
            else
                b[k++]=a[i++];
        while(i<=n)
            b[k++]=a[i++];
        while(j<=m)
            b[k++]=a[j++]; 
        for(i=0;i<k;i++)
            a[left+i]=b[i];
    }
    int main()
    {
        cin>>n;
        for(int i=1;i<=n;i++)
            cin>>a[i];
        msort(1,n);
        cout<<ans<<endl;
        return 0;
    }
 
 
     15.   1234：2011
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<algorithm>
    #include<string>
    #define INF 999999999
    #define N 500
    #define MOD 1000000007
    using namespace std;
    char a[N];
    int main()
    {
        int k;
        cin>>k;
        while(k--)
        {
            cin>>a;
            int len=strlen(a);
            int B=0,C=2011;
            int i;
 
            for(i=len-4;i<len;i++)
                if(i>=0)
                    B=B*10+a[i]-'0';
            
            i=1;
            do{
                if(i*2<=B)
                {
                    i*=2;
                    C=(C*C)%10000;
                }
            }while(i*2<=B);
            for(;i<B;i++)
                C=(C*2011)%10000;
            cout<<C<<endl;
        }
        return 0;
    }
    
   
      16.   1238：一元三次方程求解
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #define INF 999999999
    #define N 50001
    #define MOD 1000000007
    #define E 1e-5
    using namespace std;
    double a,b,c,d;
    double calculate(double x)//方程的计算 
    {
        double ans=0;
        double y=1;
     
        for(int i=1;i<=3;i++)
            y*=x;
        y*=a;
        ans+=y;
     
        y=1;
        for(int i=1;i<=2;i++)
            y*=x;
        y*=b;
        ans+=y;
     
        y=1;
        y*=x;
        y*=c;
        ans+=y;
     
        ans+=d;
        return ans;
    }
    int main()
    {
        double x=-100,x1,x2,x3;
     
        cin>>a>>b>>c>>d;
        while(x-100<=E)//第一个实根 
        {
            if(fabs(calculate(x))<=E)
                break;
            x+=0.01;
        }
        x1=x;
     
        x+=0.01;
        while(x-100<=E)//第二个实根 
        {
            if(fabs(calculate(x))<=E)
                break;
            x+=0.01;
        }
        x2=x;
     
        x+=0.01;
        while(x-100<=E)//第三个实根 
        {
            if(fabs(calculate(x))<E)
                break;
            x+=0.01;
        }
        x3=x;
        printf("%.2lf %.2lf %.2lf\n",x1,x2,x3);
        return 0;
    }
 
 
      17.  1239：统计数字
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<cmath>
    #include<string>
    #define INF 999999999
    #define N 1000001
    #define MOD 1000000007
    #define E 1e-5
    using namespace std;
    int a[N];
    void quicksort(int left,int right)
    {
        int i=left,j=right,mid=a[(left+right)/2];
        while(i<=j)
        {
            while(a[i]<mid)
                i++;
            while(a[j]>mid)
                j--;
            if(i<=j)
            {
                swap(a[i],a[j]);
                i++;
                j--;
            }
        }
        if(i<right)
            quicksort(i,right);
        if(left<j)
            quicksort(left,j);
    }
    int main()
    {
        int n;
        int cnt=1;
        cin>>n;
        for(int i=1;i<=n;i++)
            cin>>a[i];
        quicksort(1,n);
        while(cnt<=n)//当cnt不大于n时，开始循环 
        {
            int s=a[cnt],k=cnt; 
            while(s==a[cnt])//每找到一个相同的数(包括自己本身)，cnt+1 
                cnt++;
            cout<<a[cnt-1]<<" "<<cnt-k<<endl;//用cnt-k来表示找到了多少相同的数 
        }
        return 0;
    }
    
    
  18.   1241：二分法求函数的零点
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #define INF 999999999
    #define N 1000001
    #define MOD 1000000007
    #define E 1e-7
    using namespace std;
    double calculate(double x)//计算函数的值 
    {
        return x*x*x*x*x-15*x*x*x*x+85*x*x*x-225*x*x+274*x-121;
    }
    double myabs(double x){//计算数的绝对值 
        if(x<0)return -x;
        return x;
    }
    int main()
    {
        double left=1.5,right=2.4;
        while(left+E<right)
        {
            double mid=(left+right)/2.0;
            if(calculate(mid)>0)
                left=mid;
            else right=mid;
        }
        if(calculate(left)==0)
            printf("%.6lf\n",left);
        else
            printf("%.6lf\n",left);
        return 0;
    }


     19.   1245：不重复地输出数
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #define INF 999999999
    #define N 1000001
    #define MOD 1000000007
    #define E 1e-3
    using namespace std;
    int a[N];
    int main()
    {
        int n;
        cin>>n;
        for(int i=1;i<=n;i++)//读入数据 
            cin>>a[i];
        sort(a+1,a+1+n);//从小到大排序 
        cout<<a[1];
        for(int i=2;i<=n;i++)    
            if(a[i]!=a[i-1])//判断前数是否相等,确保重复的数只输一次 
                cout<<" "<<a[i];
        cout<<endl;
        return 0;
    }
    
    
    20.  1247：河中跳房子
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #define INF 999999999
    #define N 1000001
    #define MOD 1000000007
    #define E 1e-12
    using namespace std;
    int l,n,m;
    int a[N];
    int judge(int x)
    {
        int i,dis=0,num=0;
        for(int i=1;i<=n;i++)
            if(a[i]-dis<x)
                num++;
            else
                dis=a[i];
        if(l-dis<x)
            num++;
        return num<=m;
    }
    int main()
    {
        int left,right,mid;
        cin>>l>>n>>m;
        for(int i=1;i<=n;i++)
            cin>>a[i];
        left=0;
        right=l;
        while(left+1<right)
        {
            mid=(left+right)/2;
            if(judge(mid))
                left=mid;
            else
                right=mid;
        }
        cout<<left<<endl;
        return 0;
    }
    
    
21.  1261：【例9.5】城市交通路网

    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<algorithm>
    #define maxn 100
    #define inf 1e9
    int a[maxn][maxn];
    int f[maxn];
    int pre[maxn];
    using namespace std;
    int main()
    {
        int n;
      scanf("%d",&n);
        memset(a,0,sizeof(a));
        memset(pre,0,sizeof(pre));//将两个数组清零 
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)//读入数据 
          scanf("%d",&a[i][j]);
            for(int i=1;i<=maxn;i++)//如入路程 
                f[i]=inf;
                f[n]=0;
        for(int i=n-1;i>=1;i--)
            for(int j=i+1;j<=n;j++)
        {
            if(a[i][j]>0&&f[j]!=inf&&f[i]>a[i][j]+f[j])//判断是否是最短路径 
     
                {f[i]=f[j]+a[i][j];
                pre[i]=j;    //求出最少的钱 
     
        }
        }
        printf("minlong=%d\n",f[1]);
        int k=1;
        while(k!=0)
        {
            printf("%d ",k);
            k=pre[k];
     
                }
                printf("\n");
    }
   
   22.   1263：【例9.7】友好城市
    #include<iostream>
    #include<cstdio>
    #include<algorithm>
    #include<iomanip>
    using namespace std;
    struct node//表示走法 
    {
        int east,west;
    };
    node a[5100];
    int d[5100];
    bool cmp(node c,node d)//记录航道数 
    {
        return c.east<d.east;
    }
    int main()
    {
        int n;
        scanf("%d",&n);
        int i,x,len=1;
        for(i=1;i<=n;i++)
            scanf("%d%d",&a[i].east,&a[i].west);
        d[1]=a[1].west;
        sort(a+1,a+n+1,cmp);//重新排列友好城市，按cmp(从小到大)排 
        for(i=2;i<=n;i++)
        {
            x=upper_bound(d+1,d+len+1,a[i].west)-d;
            d[x]=a[i].west;
            if(x>len)len++;
        }
        cout<<len<<endl;
        return 0;
    }


     23.   1266：【例9.10】机器分配
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #include<cstdlib>
    #include<queue>
    #include<vector>
    #define INF 0x3f3f3f3f
    #define PI acos(-1.0)
    #define N 30
    #define MOD 2520
    #define E 1e-12
    using namespace std;
    int a[N][N],f[N][N],res[N][N];
    void print(int x,int y)//具体输出分机器人的方案 
    {
        if(x==0)
            return;
        print(x-1,y-res[x][y]);//递归输入 
        printf("%d %d\n",x,res[x][y]);
    }
    int main()
    {
        int n,m;
        cin>>n>>m;
        for(int i=1;i<=n;i++)//读入数据 
            for(int j=1;j<=m;j++)
                cin>>a[i][j];
 
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                for(int k=0;k<=j;k++)
                    if(f[i][j]<=f[i-1][j-k]+a[i][k])//判断多给机器给一家公司好，还是把机器给别的公司好 
                    {
                        f[i][j]=f[i-1][j-k]+a[i][k];//更新最高利润 
                        res[i][j]=k;// 记下这个方案 
                    }
 
       cout<<f[n][m]<<endl;
        print(n,m);
 
       return 0;
    } 
    
     24.  1282：最大子矩阵
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #include<cstdlib>
    #include<queue>
    #include<vector>
    #define INF 0x3f3f3f3f
    #define PI acos(-1.0)
    #define N 1001
    #define MOD 2520
    #define E 1e-12
    using namespace std;
    int a[N][N],f[N];
    int maxArray(int t[],int n)//计算出最大区域的值 
    {
        int sum=0,maxx=-INF;
        for(int i=1;i<=n;i++) 
        {
            if(sum>0)
                sum+=t[i];
            else
                sum=t[i];
            if(sum>maxx)
                maxx=sum;
        }
    
        return maxx;
    }
    int main()
    {
        int n;
        cin>>n;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)//读入数据 
                cin>>a[i][j];
 
        int maxx=-INF;
        for(int i=1;i<=n;i++)
        {
            memset(f,0,sizeof(f));//清空数据 
            for(int j=i;j<=n;j++)
            {
                for(int k=1;k<=n;k++)
                    f[k]+=a[j][k];//开始累加 
 
                int temp=maxArray(f,n); 
                if(temp>maxx)//选出最大值 
                    maxx=temp;
            }
        }
 
        cout<<maxx<<endl;
 
        return 0;
    } 
     25.   1286：怪盗基德的滑翔翼
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #include<cstdlib>
    #include<queue>
    #include<vector>
    #define INF 0x3f3f3f3f
    #define PI acos(-1.0)
    #define N 1001
    #define MOD 2520
    #define E 1e-12
    using namespace std;
    int a[N],f[N];
    int main()
    {
        int t;
        cin>>t;
        while(t--)
        {
            int n;
            cin>>n;
            for(int i=1;i<=n;i++)
                cin>>a[i];
     
            int maxx1=-INF,maxx2=-INF;
            for(int i=1;i<=n;i++)
            {
                f[i]=1;
                for(int j=1;j<i;j++)
                    if(a[j]>a[i]&&f[j]+1>f[i])//计算从第一个开始的经过的最多的楼数 
                        f[i]=f[j]+1;
                    maxx1=max(maxx1,f[i]);
           }
            for(int i=n;i>=1;i--)
            {
                f[i]=1;
                for(int j=n;j>i;j--)
                    if(a[j]>a[i]&&f[j]+1>f[i])//计算从最后一个开始的经过的最多楼数 
                        f[i]=f[j]+1;
                maxx2=max(maxx2,f[i]);
        }
            
            int res=max(maxx1,maxx2);
            cout<<res<<endl;
        }
        return 0;
    }
    
    
      26.   1287：最低通行费
      #include<iostream>
      #include<cstdio>
      #include<cstring>
      #include<cmath>
      #include<algorithm>
      #include<string>
      #include<cstdlib>
      #include<queue>
      #include<vector>
      #define INF 0x3f3f3f3f
      #define PI acos(-1.0)
      #define N 1001
      #define MOD 2520
      #define E 1e-12
      using namespace std;
      int a[N][N],f[N][N];
      int main()
      {
          int n;
          cin>>n;
          for(int i=1;i<=n;i++)
              for(int j=1;j<=n;j++)
                  cin>>a[i][j];
 
          f[1][1]=a[1][1];
          for(int i=2;i<=n;i++)
              f[i][1]=f[i-1][1]+a[i][1];//算出向下走的所有的值并储存 
          for(int j=2;j<=n;j++)
              f[1][j]=f[1][j-1]+a[1][j];//算出向左走的所有的值并储存 
 
          for(int i=2;i<=n;i++)
              for(int j=2;j<=n;j++)
                  f[i][j]=min(f[i-1][j],f[i][j-1])+a[i][j];//比较出向下走还是向右走省钱 
 
          cout<<f[n][n]<<endl;
 
          return 0;
      }
      
      
       27.   1267：【例9.11】01完全背包问题
      #include<iostream>
      #include<cstdio>
      #include<cstring>
      #include<cmath>
      #include<algorithm>
      #include<string>
      #include<cstdlib>
      #include<queue>
      #include<vector>
      #define INF 0x3f3f3f3f
      #define PI acos(-1.0)
      #define N 1001
      #define MOD 2520
      #define E 1e-12
      using namespace std;
      int m,n;
      int w[N],c[N],f[N];
      void CompletePack(int cost,int weight)//算出当前价值最大的值 
      {
          for(int v=weight;v<=m;v++)
              f[v]=max(f[v],f[v-weight]+cost);    
      }
 
      int main()
      {
          cin>>m>>n;
          for(int i=1;i<=n;i++)//读入数据 
              cin>>w[i]>>c[i];
          for(int i=1;i<=n;i++) 
              CompletePack(c[i],w[i]);
          cout<<"max="<<f[m]<<endl;
          return 0;
      }
    
     29.   1270：【例9.14】混合背包
    #include<bits/stdc++.h>
    using namespace std;
    int cost[555],value[555],num[555];
    int dp[6666];
    int main(){
        int n,m;
        cin>>m>>n;
        for(int i=1;i<=n;i++){
            cin>>cost[i]>>value[i]>>num[i];
        }
        for(int i=1;i<=n;i++){
            if(num[i]==0){//当可以取无限次时 
                for(int j=cost[i];j<=m;j++){
                    dp[j]=max(dp[j],dp[j-cost[i]]+value[i]);//在背包体积之内，找出最有价值的方案 
                }
            }else{//不能取无限次时 
                for(int j=1;j<=num[i];j++){ //记录是否超过了物品可取的次数 
                    for(int k=m;k>=cost[i];k--){
                        dp[k]=max(dp[k],dp[k-cost[i]]+value[i]);//找出最有价值的方案 
                    }
                }
            }
        }
        cout<<dp[m]<<endl;
        return 0;
    }


     30.   1272：【例9.16】分组背包
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #include<cstdlib>
    #include<queue>
    #include<vector>
    #define INF 0x3f3f3f3f
    #define PI acos(-1.0)
    #define N 1001
    #define MOD 2520
    #define E 1e-12
    using namespace std;
    int v,n,t;
    int group[N][N],w[N],c[N],f[N];
    void GroupPack(int groupp,int num)
    {
        for(int j=v;j>=0;j--)
            for(int k=1;k<=groupp;k++)//每小组选一个 
            {
                int q=group[num][k];//物品序号
                cout<<j<<endl;
                if(j>=w[q])
                    f[j]=max(f[j],f[j-w[q]]+c[q]);//选出价值最大的物品 
            }
     }
    int main()
    {
        int p;
        cin>>v>>n>>t;
        for(int i=1;i<=n;i++)
        {
            cin>>w[i]>>c[i]>>p;
            group[p][++group[p][0]]=i;//group[p][0]存储p组元素个数
        }
 
        for(int i=1;i<=t;i++)
            GroupPack(group[i][0],i);
        cout<<f[v]<<endl;
        return 0;
    }
     31.   1291：数字组合
    #include<stdio.h>
    #include<iostream>
    #include<string.h>
    #define inf 0x3f3f3f3f
    using namespace std;
    int main()
    {   
	    long long n,t,a[10005],dp[10005],i,j;
	    while(scanf("%lld %lld",&n,&t)!=EOF)
	    {
	        memset(dp,0,sizeof(dp)); 
		    dp[0]=1;
		    for(i=1;i<=n;i++)
		        scanf("%d",&a[i]);
	            for(i=1;i<=n;i++)
		    {
			
			    for(j=t;j>=a[i];j--){//不同点，逆序
			        dp[j]+=dp[j-a[i]];//找出方式的数目 
			        cout<<dp[j]<<" ";
		        }
		    }
		    printf("%lld\n",dp[t]);
	    }
    }
       32.   1296：开餐馆
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #include<cstdlib>
    #include<queue>
    #include<vector>
    #define INF 0x3f3f3f3f
    #define PI acos(-1.0)
    #define N 1001
    #define MOD 2520
    #define E 1e-12
    using namespace std;
    int w[N],c[N],f[N];
    int main()
    {
        int t;
        cin>>t;
        while(t--)
        {
            int n,k;
            cin>>n>>k;
            for(int i=1;i<=n;i++)//读入数据（开店的地点） 
                cin>>w[i];
            for(int i=1;i<=n;i++)//读入利润 
            {
                cin>>c[i];
                f[i]=c[i];
            }
 
            for(int i=1;i<=n;i++)
                for(int j=1;j<=n;j++)
                    if(w[i]-w[j]>k)//当两家店距离相差k以上时 
                        f[i]=max(f[i],f[j]+c[i]);//->选出是这两家店利润大，还是其他的选择更好 
 
            int maxx=-INF;
            for(int i=1;i<=n;i++)//比较哪种方案更好 
                maxx=max(f[i],maxx);
            cout<<maxx<<endl;
        }
        return 0;
    } 
    
    
      33.   1274：【例9.18】合并石子
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #include<cstdlib>
    #include<queue>
    #include<vector>
    #define INF 0x3f3f3f3f
    #define PI acos(-1.0)
    #define N 101
    #define MOD 2520
    #define E 1e-12
    using namespace std;
    int sum[N],f[N][N];
   int main()
    {
        int n,a;
        memset(f,INF,sizeof(f));
     
        cin>>n;
        sum[0]=0;
        for(int i=1;i<=n;i++)
       {
            cin>>a;
            sum[i]=sum[i-1]+a;
        }
        for(int i=1;i<=n;i++)
            f[i][i]=0;
        for(int i=n;i>=1;i--)
            for(int j=i+1;j<=n;j++)
                for(int k=i;k<=j-1;k++)
                    f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+sum[j]-sum[i-1]);
        cout<<f[1][n]<<endl;
        return 0;
    } 
    
    
     34.   1277：【例9.21】方格取数
/*思路

考虑两个人同时从A出发，则需考虑两个人到达任意两个格子(i1，j1)与(i2，j2)的情况，显然要到达这两个格子，其前一状态必为(i1-1，j1)，(i2-1，j2)；(i1-1，j1)，(i2，j2-1)；(i1，j1-1)，(i2-1，j2)；(i1，j1-1)，(i2，j2-1) 四种情况之一。
于是，可以推出动态转移方程：
f[i][j][k][s]=max(max(f[i?1][j][k?1][s],f[i?1][j][k][s?1]),max(f[i][j?1][k][s?1],f[i][j?1][k?1][s]))+a[i][j]+a[k][s];

f[i][j][k][s]=max(max(f[i?1][j][k?1][s],f[i?1][j][k][s?1]),max(f[i][j?1][k][s?1],f[i][j?1][k?1][s]))+a[i][j]+a[k][s];
但是，我们要处理一下，如果这两条路线走在了一起，就只算一次。
代码
*/
#include<cstdio>
#include<iostream>
using namespace std;
int n,a[11][11],f[11][11][11][11];//初始化
int main()
{
	scanf("%d",&n);//输入
	int he,ha,ho;//初始化
	scanf("%d%d%d",&he,&ha,&ho);//输入
	while(he!=0&&ha!=0&&ho!=0)//判断是否结束
	{
		a[he][ha]=ho;//标记
		scanf("%d%d%d",&he,&ha,&ho); //持续输入
	}
	for(register int i=1;i<=n;i++)//枚举第一条路线的列
	for(register int j=1;j<=n;j++)//枚举第一条路线的行
	for(register int k=1;k<=n;k++)//枚举第二条路线的列
	for(register int s=1;s<=n;s++)//枚举第二条路线的行
	{
		f[i][j][k][s]=max(max(f[i-1][j][k-1][s],f[i-1][j][k][s-1]),max(f[i][j-1][k][s-1],f[i][j-1][k-1][s]))+a[i][j]+a[k][s];//动态转移方程
		if(i==k&&s==j) f[i][j][k][s]-=a[i][j];//处理走在一起的情况
	}
	printf("%d",f[n][n][n][n]);//输出
	return 0;
}

     35.   1279：【例9.23】橱窗设置（flower）
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #include<cstdlib>
    #include<queue>
    #include<vector>
    #define INF 0x3f3f3f3f
    #define PI acos(-1.0)
    #define N 101
    #define MOD 2520
    #define E 1e-12
    using namespace std;
    int a[N][N],b[N][N],c[N][N],d[N];
    int main()
    {
        int f,v;
        cin>>f>>v;
        for(int i=1;i<=f;i++)
            for(int j=1;j<=v;j++)
                cin>>a[i][j];
 
        memset(b,128,sizeof(b));
        for(int i=1;i<=v-(f-1);i++)
            b[1][i]=a[1][i];
        for(int i=1;i<=f;i++)
            for(int j=i;j<=v-(f-i);j++)
                for(int k=i-1;k<=j-1;k++)
                    if(b[i][j]<b[i-1][k]+a[i][j])//读入美学值 
                    {
                        b[i][j]=b[i-1][k]+a[i][j];
                        c[i][j]=k;
                    }
 
        int maxx=-INF;
        int temp;
        for(int i=f;i<=v;i++)
            if(b[f][i]>maxx)//选出美学值最大的组合 
            {
                maxx=b[f][i];
                temp=i;
            }
        cout<<maxx<<endl;//输入这个组合的美学值 
 
        for(int i=f;i>=1;i--)
        {
            d[f-(i-1)]=temp;
            temp=c[i][temp];
        }
  
        for(int i=f;i>=1;i--)
            cout<<d[i]<<" ";//输入花瓶号码 
        return 0;
    }


     36.   1280：【例9.24】滑雪
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    using namespace std;
    #define M 500
    #define INF 0x3f3f3f3f
    int f[M][M];
    int r, c, map[M][M], ans;
    int dx[] = {0, 0, 1, -1};
    int dy[] = {1, -1, 0, 0};
     
    int dfs(int x, int y)
    {
        if(f[x][y]) return f[x][y];
        int maxx = 1;
        int step = 0;
        for(int i = 0; i < 4; i++) {//输入走法 
            int xx = x + dx[i];
            int yy = y + dy[i];
            step = 0;
            if(xx <= 0 || xx > r || yy <= 0 || yy > c) continue; 
            if(map[xx][yy] < map[x][y]) step = dfs(xx, yy) + 1;//将不同的可能性存入step中 
            maxx = max(maxx, step);//选出最长滑坡 
        }
        f[x][y] = maxx;
        return f[x][y];
    }
     
    int main() {
        scanf("%d%d", &r, &c);
        for(int i = 1; i <= r; i++)
            for(int j = 1; j <= c; j++) scanf("%d", &map[i][j]);
        for(int i = 1; i <= r; i++)
            for(int j = 1; j <= c; j++) {
                f[i][j] = dfs(i, j);
                ans = max(ans, f[i][j]);
            }
        printf("%d\n", ans);
        return 0;
    } 
    
     37.   1298：计算字符串距离
     /*
    状态转移方程：f[i][j]表示ai与bj的最优编辑距离。

    首先f[i][0]和f[0][i]都初始化为i，插入和删除的步数

    如果a[i]=b[j]那么f[i][j]=f[i-1][j-1]（不动）

    否则f[i][j]=min(min(f[i-1][j],f[i][j-1])(插入，删除),f[i-1][j-1](把一个字符改成另一个字符))+1
    */

    #include <cstdio>
    #include <algorithm>
    #include <cstring>
    using namespace std;
    char s1[2001],s2[2001]; int f[2001][2001],n,t,m;
    int main(){
    scanf("%d",&t);
    while (t--){
        scanf("%s%s",s1,s2); n=strlen(s1); m=strlen(s2);
        memset(f,0,sizeof(f));
        for (int i=1;i<=n;i++) f[i][0]=i;//初始化
        for (int i=1;i<=m;i++) f[0][i]=i;//初始化
        for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
        if (s1[i-1]==s2[j-1]) f[i][j]=f[i-1][j-1];//相等则不变    
        else f[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1])+1;//否则步数+1
        printf("%d\n",f[n][m]); }return 0;
    }

    
     38.   1300：鸡蛋的硬度
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #include<cstdlib>
    #include<queue>
    #include<vector>
    #define INF 0x3f3f3f3f
    #define PI acos(-1.0)
    #define N 1001
    #define MOD 2520
    #define E 1e-12
    using namespace std;
    int f[110][20];
    int main()
    {
        int n,m;
        while(scanf("%d%d",&n,&m)!=EOF)
        {
            for(int i=1;i<=n;i++)
                for(int j=1;j<=m;j++)
                    f[i][j]=i;
 
            for(int i=1;i<=n;i++)
                for(int j=1;j<=i;j++)
                    for(int k=2;k<=m;k++)
                        f[i][k]=min(f[i][k],max(f[j-1][k-1],f[i-j][k])+1);
  
            cout<<f[n][m]<<endl;
        }
        return 0;
   }
        39.   1302：股票买卖
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<cmath>
    #include<algorithm>
    #include<string>
    #include<cstdlib>
    #include<queue>
    #include<vector>
    #define INF 0x3f3f3f3f
    #define PI acos(-1.0)
    #define N 100001
    #define MOD 100001
    #define E 1e-12
    using namespace std;
    int a[N],f1[N],f2[N];
    int main()
    {
        int t,ans;
        scanf("%d",&t);
        while(t--)
        {
            int n;
            scanf("%d",&n);
            for(int i=1;i<=n;i++)
                scanf("%d",&a[i]);//读入数据 
  
            int minn=INF,maxx=-INF;
            f1[0]=0;
            f2[n+1]=0;
            for(int i=1;i<=n;i++)
            {
                minn=min(minn,a[i]); 
                f1[i]=max(f1[i-1],a[i]-minn);//正序枚举选出所有可能性中利益最大的一个 
            }
            cout<<endl;
            for(int i=n;i>=1;i--)
            {
                maxx=max(maxx,a[i]);
                f2[i]=max(f2[n+1],maxx-a[i]);//倒叙枚举选出所有可能性种利益最大的一个
            }
 
            int ans=-INF;
            for(int i=1;i<=n;i++)
                ans=max(ans,f1[i]+f2[i]);
            printf("%d\n",ans);
        }
        return 0;
    }
     40.   1305：Maximum sum
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define maxn 50005
int lsum[maxn];
int rsum[maxn];

int t,n;
int a[maxn];
using namespace std;
int main()
{
    scanf("%d",&t);
    while(t--)
    {
	    memset(lsum,0,sizeof(lsum));
        memset(rsum,0,sizeof(rsum));
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
            scanf("%d",&a[i]);
        lsum[1]=a[1];
        for(int i=2;i<=n;i++)
            if(lsum[i-1]>0)
            lsum[i]=lsum[i-1]+a[i];
        else
            lsum[i]=a[i];
        rsum[n]=a[n];
        for(int i=n-1;i>=1;i--)
            if(rsum[i+1]>0)
            rsum[i]=rsum[i+1]+a[i];
        else
            rsum[i]=a[i];
        int maxx=-10000000;
        int maxl=-10000000;
        for(int i=1;i<n;i++)
        {
            if(lsum[i]>maxx)
                maxx=lsum[i];
            if(rsum[i+1]+maxx>maxl)
                maxl=maxx+rsum[i+1];

        }
        printf("%d\n",maxl);
    }
    return 0;
}
     41.   1306：最长公共子上升序列
    #include<cstdio>
    #include<iostream>
    #include<cstring>
    using namespace std;
    int b[501][501],b2[501][501],f[501][501],a1[501],a2[501],max1,max2,m1,m2;
    bool ok[501][501];
    void print(int x,int y)
    {
        if (b[x][y]==0 && b2[x][y]==0 || x<=0 || y<=0) {printf("%d ",a1[x]);return;}
        print(x-b[x][y],y-b2[x][y]);
        printf("%d ",a1[x]);
    }//输出序列
    int main()
    {
        scanf("%d",&m1);
        for (int i=1;i<=m1;i++) scanf("%d",&a1[i]);
        scanf("%d",&m2);
        for (int i=1;i<=m2;i++) scanf("%d",&a2[i]); 
        //输入
        for (int i=1;i<=m1;i++)//枚举第一个序列开头
        {
          for (int j=1;j<=m2;j++)//枚举第二个开头
          {
            f[i][j]=1;//改变
            if (f[i][j]<f[i-1][j])
            {
              f[i][j]=f[i-1][j];
              b[i][j]=1;


              b2[i][j]=0;
            }//判断路径输出
            if (f[i][j]<f[i][j-1])
            {
              f[i][j]=f[i][j+1];
              b[i][j]=0;
              b2[i][j]=1;
            }//判断路径输出
            if (a1[i]==a2[j])//开头相同
            {
              for (int k=1;k<i;k++)
                for (int k2=1;k2<j;k2++)//往下枚举
                {
                  if (f[i][j]<=f[i-k][j-k2]+1 && a1[i]>a1[i-k] && a1[i-k]==a2[j-k2])
                  {
                    f[i][j]=f[i-k][j-k2]+1;//动态转移
                    b[i][j]=k;
                    b2[i][j]=k2;//记录过程
                  }
                }
              if (f[max1][max2]<f[i][j]) {max1=i;max2=j;}//改变最大值
             }
            else {ok[i][j]=true;}//输出防止输出没有的数
          }
        }
        printf("%d\n",f[max1][max2]);

        if (f[max1][max2]!=0)
        {
            print(max1,max2);
        }
    }
    
    
    
    
42.   1322：【例6.4】拦截导弹问题(Noip1999)
    #include<iostream> 
    #include<cstring>
    #define MAXN 1000
    using namespace std;
    int a[MAXN+10];//导弹飞来时的高度 
    int l[MAXN+10];//拦截导弹最低高度 
    int main()
    {
	    memset(a,0,sizeof(a));
	    memset(l,0,sizeof(l));
	    int n=1;
	    while(cin>>a[n])
	    {
	    	n++;
	    }
	    int k=1;//拦截导弹系统数
	    int p,j=1;
	    l[k]=a[1]; 
	    for(int i=2;i<=n;i++) 
	    {
		    p=0;//注意每次循环时需要p=0 
		    for(int j=1;j<=k;j++)//注意，j<=k 
		    {
			    if(l[j]>=a[i])
			    {
				    if(p==0) p=j;
				    else if(l[p]>l[j]) p=j;//如果同时满足例如l[1]=155>65,l[2]=158>65,
				    //则应该应将最小值赋值给最小拦截系统 
			    }
		    }
		    if(p==0)
		    {
			    k++;//如果发现a[i]>l[j],则应该增加一个系统 
			    l[k]=a[i];//更新新系统的最小值 
		    }
		    else l[p]=a[i];//更新原系统的拦截最小值 
	    }
	    cout<<k<<endl;
	    return 0;
    }
    /*例如有8个导弹，高度分别是： 389 207 155 | 300 299 170 158 65
    ‘|’之前是系统1的范围，‘|’后面是系统2的范围
    如上代码，
    因为l[1]=>389=>207=>155  l[1]=155<300，所以 k++(系统数加一),l[2]=300=>299=>170=>158
    当l[1]=155>65
      l[2]=158>65时
      min(l[1],l[2])=65;*/
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    




















	
      


	
         
