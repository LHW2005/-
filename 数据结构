第二章 线性结构
    2.堆栈
    ·中缀表达式：运算符号位于两个运算数之间。如，a+b*c-d/e
    ·后缀表达式：运算符号位于两个运算数之后。如，abc*+de/-
    后缀表达式求值策略：从左向右“扫描”，逐个处理运算数和运算符号
        1.遇到运算数怎么办？如何“记住”目前还未参与运算的数？
        1.遇到运算符号怎么办？对应的运算数是什么？
    
    启示：需要有种存储方法，能顺序存储运算数，并在需要时“倒序”输出！
    
    堆栈的抽象数据类型描述
        堆栈：具有一定操作约束的线性表
         ·只在一端（栈顶，top）做插入，删除
        
        ·插入数据：入栈（Push）
        ·删除数据：出栈（Pop）
       *·后入先出：Last In First Out(LIFO)
    
    类型名称：堆栈（Stack）
    数据对象集：一个有0个或多个元素的又穷性表。
    操作集：长度为MaxSize的堆栈S∈Stack,堆栈元素item∈ElementType
    1.Stack CreateStack(int MaxSize):生成空堆栈，其最大长度为MaxSize;
    2.int IsFull(Stack S,int MaxSize):判断堆栈S是否已满：
    3.void Push(Stack S,ElementType item):将元素item压入堆栈；
    4.int IsEmpty(Stack S):判断堆栈S是否为空；
    5.ElementType Pop(Stack S):删除并返回栈顶元素；
    
    堆栈的链式存储实现
        栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行。栈顶指针Top应该在链表的哪一头？（答：在链表的开头）
        
   3.队列及实现 
        队列：具有一定操作约束的线性表
            ·插入和删除操作：只能在一端插入，而在另一端删除。
            ·数据插入：入队列（AddQ）
            ·数据删除：出队列（DeleteQ）
            ·先来先服务
            ·先进先出：FIFO
            
        队列的抽象数据类型描述
        类型名称：队列（Queue）
        数据对象集：长度为Maxsize的队列Q∈Queue,队列元素item∈ElementType
        1.Queue CreatQueue(int MaxSize):生成长度为MaxSize的空队列；
        2.int IsFullQ(Queue,Q,int MaxSize):判断队列Q是否已满；
        3.void AddQ(Queue Q,ElementType item):将数据元素item插入队列Q中；
        4.int IsEmptyQ(Queue Q):判断队列Q是否为空；
        5.ElementType DeleteQ(Queue Q)：将对头数据元素从队列中删除并返回。
        
        队列的顺序存储实现
            队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的front以及一个记录队列为原素位置的变量rear祖成
            例：
                #define MaxSize<存储数据元素的最多个数
                struct QNod{
                    ElementTye datea [MaxSiec];
                    int eral;
                    int ffron;'
                    
                }
                tyedef truce  QNod*Queen;
        
    第三章  树（上）
        1.树与树的表示
           什么是树
           客观世界中许多事物存在层次关系
            例如：·人类社会家谱
                 ·社会组织结构
                 ·图书信息管理
           分层次组织在管理上具有更高的效率！
           数据管理的基本操作之一：查找
               如何实现有效率的查找？
               
           查找（Searching）
             查找：根据某个给定关键字K,从集合R中找出关键字与K相同的纪录
             静态查找：集合中记录是固定的
                 ·没有插入和删除操作，只有查找
             动态查找：集合中记录是动态变化的
                 ·除查找，还可能发生插入和删除
           
            静态查找：
             方法1：顺序查找
             方法2：二分查找
               条件:假设n个数据元素的关键字满足有序（比如：小到大）
                           k1<k2<·····<kn
                    并且是连续存放（数组），那么可以进行二分查找。
           
           
           二分查找形成了一个判定树
               ·判定树上每个节点需要的查找次数刚好为该结点所在的层数；
               ·查找成功时查找次数不会超过判定树的深度
               ·n个结点的判定树的深度为[log(2)n]+1.
               ·ASL(平均成功查找次数)=(4*4+4*3+3*3+1)/11=3
           
          
       树（tree）：n(n>=0)个结点构成的有限集合。
           当n=0时，称为空树；
           对于任意一棵非空树（n>0），它具备以下性质；
           ·树中有一个称为“根（Root）”的特殊结点，用r表示；
           ·其余结点可分为m(m>0)个互不相交的有限集T1，T2,····，Tm,其中每个集合本身又是一棵树，称为原来树的“子树（SubTree）”
            
      注意：·子树是不相交的；
           ·除了根节点外，每个结点有且仅有一个父节点；
           ·一棵N个结点的树有N-1条边。
            
        
         树的一些基本用语
             1.结点的度（Degree）:结点的子树个数
             2.树的度：树的所有结点中最大的度数
             3.叶结点（Leaf）：度为0的结点
             4.父结点（Parent）：有子树的结点时其子树的根的根结点的父结点
             5.子结点（Child）：若A结点是B结点的父结点，则称B结点是A结点的子结点；子结点也称孩子结点。
             6.兄弟结点（Sibling）：具有同一父结点的各结点彼此是兄弟结点。
             7.路径和路径长度：从结点n1到nk的路径为一个结点序列n1,n2,.....nk,nj是nj+1的父结点。路径所包含的个数为路径的长度。
             8.祖先结点（Ancestor）：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。
             9.子孙结点（Descendant）：某一结点的子树中的所有结点是这个结点的孙子。
             10.结点的层次（Level）：规定根结点在1层，其它任一结点的层数是其父结点的层数加1.
             11.树的深度（Depth）：树中所有结点中的最大层次是这棵树的深度。
    
    书的表示
        1.儿子兄弟表示法
           链表
                 Element
           FirstChild  NextSibling
           FirstChild->儿子，NextSiblin->兄弟（二叉树）
    
    二叉树的定义
        二叉树T：一个有穷的结点集合。
            这个集合可以为空
            若不为空，则它是由根结点和称为其左子树T(L)和右子树T(R)的两个不相交的二叉树组成。
        二叉树几个重要性质
        ·一个二叉树第i层的最大节点数为：2^k-1,i>=1.
        ·深度为k的二叉树有最大结点总数为：2^k-1,k>=1.
        ·对任何非空二叉树T，若n(0)表示叶结点的个数，n(2)是度为2的非叶结点个数，那么两者满足关系n(0)=n(2)+1。
        
        二叉树的抽象数据类型定义
        类型名称：二叉树
        数据对象集：一个有穷的结点集合。
            若不为空，则由根结点和其左，右二叉子树组成。
        操作集：BT∈BinTree,Item∈ElementType,重要操作有：
              1.Boolen IsEmpty(BinTree BT):判别BT是否为空;
              2.void Traversal(BinTree BT):遍历，按某顺序访问每个结点；
              3.BinTree CreatBinTree():创建一个二叉树。
              
              常用的遍历方法有：
              ·void PreOrderTraversal(BinTree BT):先序----根，左子树，右子树；
              ·void InOrderTraversal(BinTree BT):中序----左子树，根，右子树；
              ·void PostOrderTraversal(BinTree BT):后序----左子树，右子树，根
              ·void LevelOrderTraversal(BinTree BT):层次遍历，从上到下，从左到右
              
              
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
