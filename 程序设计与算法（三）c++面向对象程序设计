第一周
    3.动态内存分配
        用new运算符实现动态内存分配
          ·第一种用法，分配一个变量；
          P=new T;
          T是任意类型名，P是类型为T*的指针。
          动态分配出一片大小为sizeof(T)字节的内存空间，并且将该内存的起始地址赋值给P。
          例如：
              int *pn;
              pn=new int;
              *pn=5;
          
          ·第二种用法，分配一个数组：
          P=new T[N];
          T:任意类型名
          P:类型为T*的指针
          N:要分配的数组元素的个数，可以是整型表达式
            动态分配出一片大小为N*sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P。
          示例：
              int*pn;
              int i=5;
              pn=new int[i*20];
              pn[0]=20;
              pn[100]=30;//编译没问题。运行时导致数组越界
              
          ·new运算符的返回值类型：
          new T;
          new T[n];
          这两个表达式返回值的类型都是T*
          int *p=new int;
          
          ·用delete运算符释放动态分配的内存
              ·用“new”动态分配的内存空间，一定要用“delete”运算符进行释放
              delete指针：//该指针必须指向new出来的空间
          int*p=new int;
          *p=5;
          delete p;
          delete p;  //导致异常，一片空间不能被delete多次
              ·用“delete”释放动态分配的数组，要在指针前加“[]”
              delete[]指针：//该指针必须指向new出来的数组
          int *p=new int[20];
          p[0]=1;
          delete []p;
          
    4.内联函数和重载函数
        内联函数
        ·函数调用是有时间开销的。如果函数本身只有几条语句，执行非常快，而且函数被
        反复执行很多次，相比之下调用函数所产生的这个开销就会显得比较大。
        ·为了减少函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语
        句时，是将整个函数的代码插入的到调用语句处，而不会产生调用函数的语句。
         
        在函数定义前面加“inline”关键字，即可定义内联函数
        inline int Max(int a,int b)
        {
            if(a>b) return a;
            return b;
        }
          
        函数重载
        ·一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载。
        ·以下三个函数是重载关系：
            int Max(double f1,double f2){}
            int Max(int n1,int n2){}
            int Max(int n1,int n2,int n3){}
        ·函数重载使得函数命名变得简单。
        ·编译器根据调用语句中的实参的个数和类型判断应该调用哪个函数。
        
        函数的缺省参数
        ·c++中，定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调
        用函数的时候，若相应位置不写参数，参数就是缺省值。
        示例:
            void func(int x1,int x2=2,int x3=3){}
            func(10);//等效于func(10,2,3)
            func(10,8);//等效于func(10,8,3)
            func(10,,8);//不行，只能最右边的连续若干个参数缺省
        
        ·函数参数可缺省的目的在于提高程序的可扩充性。
        ·即如果某个写好的函数要添加新的参数，而原先那些该调用该函数的语句，未必需要使用新增的参数，那么
        为了避免对原先那些函数调用语句的修改，就可以使用缺省参数。
        
        
    5.类和对象的基本概念（1）
    结构化程序设计
    ·c语言使用结构化程序设计：
        程序=数据结构+算法
    ·程序由全局变量以及众多相互调用的函数组成的。
    ·算法以函数的形式实现，用于对数据结构进行操作。
          
    结构化程序设计的不足
    ·结构化程序设计中，函数和其所操作的数据结构，没有直观的联系。
    ·随着程序规模的增加，程序逐渐难以理解，很难一下子看出来：
        ·某个数据结构到底有哪些函数可以对它进行操作？
        ·某个函数到底是用来操作那些数据结构的？
        ·任何两个数之间存在怎样的调用关系？
    ·结构化程序设计没有“封装”和“隐藏”的概念。
    要访问某个数据结构中的某个变量，就可以直接访问，那么当该变量的定义有改动的时候，
    就要把所有访问该变量的语句找出来修改，十分不利于程序的维护，扩充。
    ·难以查错，当某个数据结构的值不正确时，难以找出到底是那个函数导致的。
    
    ·重用：在编写某个程序时，发现其需要的某项功能，在现有的某个程序里已经有了相同或类似的实现，
    那么自然希望能够将那部分代码抽取出来，在新程序中使用。
    ·在结构化程序设计中， 随着程序规模的增大，由于程序大量函数，变量之间的关系错综复杂，要抽取
    部分代码，会变得十分困难。
          
    面向对象的程序设计
    ·面对对象的程序设计方法，能够较好解决上述问题。
    面向对象的程序=类+类+类+······+类
    ·设计程序的过程，就是设计类的过程
    
    ·面向对象的程序设计方法：
       ·将某类客观事物共同特点（属性）归纳出来，形成一个数据结构（可以用多个变量描述事物的属性）；
       ·将这类事物所能进行的行为也归纳出来，形成一个个函数，这些函数可以用来操作数据结构（这一步叫“抽象”）。
       ·然后，通过某种语法形式，将数据结构和操作数据结构的函数“捆绑”在一起，形成一个“类”，从而使得数据结构和
       操作该数据结构的算法呈现出显而易见的紧密关系，这就是“封装”。
       ·面向对象的程序设计具有“抽象”，“封装”，“继承”，“多态”四个基本特点。
          
   从客观事物抽象出类
   ·写一个程序，输入矩形的长和宽，输入面积和周长。
   ·比如对于“矩形”这种东西，要用一个类来表示，该如何做“抽象”呢？
   ·矩形的属性就是长和宽。因此需要两个变量，分别代表长和宽。
   ·一个矩形，可以有哪些行为呢（或可以对矩形进行哪些操作）？
       ·矩形可以有设置长和宽，算面积，和算周长这三种行为（当然也可以有其他行为）。
       ·这三种行为，可以各用一个函数来实现，他们都需要用到长和宽这两个变量。
          
   ·将长，宽变量和设置长，宽，求面积，以及求周长的三个函数“封装”在一起，就能形成一个“矩形类”。
   ·长，宽变量成为该“矩形类”的“成员变量”，三个函数成为该类的“成员函数”。成员变量和成员函数统称为类的成员。
   ·实际上，“类”看上去就像“带函数的结构”。
          
    ·通过类，可以定义变量。类定义出来的变量，也称为类的实例，也就是我们所说的“对象”。
    ·C++中，类的名字就是用户定义的类型的名字。可以像使用基本类型那样使用它。CRectangle就是一种用户自定义的类型。
    
    ·和结构变量一样，对象所占用的内存空间的大小，等于所有成员变量的大小之和。
    ·每个对象各有自己的存储空间。一个对象的某个成员变量被改变了，不会影响到另一个对象。
          
    对象之间的运算
        和结构变量一样，对象之间可以用“=”进行赋值，但是不能用“==”，“！=”，“>”，“<”，“>=”，“<=”进行比较，除非
        这些运算符经过了“重载”。
          
    使用类的成员变量和成员函数
        用法一：对象名.成员名
        CRectangle r1,r2;
        r1.w=5;
        r2.Init(5.4);
    ·lnit函数作用在r2上，即lnit函数执行期间访问的w和h是属于r2这个对象的，执行r2.lnit不会影响到r1。
        用法二:指针->成员名
        CRectangle r1,r2;
        CRectangle *p1=&r1;
        CRectangle *p1=&r2;
        p1->w=5;
        p2->Init(5,4);//lnit作用在p2指向的对象上
        
        用法三：引用名.成员名
            CRectangle r2;
            CRectangle &rr=r2;
            rr.w=5;
            rr.Init(5.4);//rr的值变了，r2的值也变
            
     类的成员函数和类的定义分开写
     class CRectangle{
         public:
             int w,h;
             int Area();     //成员函数仅在此处声明
             int Perimeter();
             void Init(int w_,int h_);
     }
     int CRectangle::Area(){
         return w*h;
     }
     int CRectangle::Area(){
         return 2*(w+h);
     }
     void CRectangle::Init(int w_,int h_){
         w=w_;h=h_;
     }
     CRectangle::说明后面的函数是CRectangle类的成员函数，而非普通函数。那么，一定要通过对象或对象的指针或对象
     的引用才能调用。
     
     类成员的可访问范围
     ·在类的定义中，用下列访问范围关键字来说明类成员被访问的范围：
     -private:私有成员，只能在成员函数内访问
     -public：公有成员，可以在任何地方访问
     -protected：保护成员，以后再说
     ·以上三种关键字出现的次数和先后次序都没有限制。
     
     如果某个成员前面没有上述关键字，则缺省地被认为是私有成员。
     
     ·在类的成员函数内部，能够访问：
     -当前对象的全部属性，函数；
     -同类其它对象的全部属性，函数。
     ·在类的成员函数以外的地方，只能够访问该类对象的公有函数。
     ·设置私有成员的机制，叫“隐藏”
     ·“隐藏”的目的是强制对成员变量的访问一定要通过成员函数进行，那么以后成员变量的类型等属性修改后，只需要更改
     成员函数即可。否则，所有直接访问成员变量的语句都需要被修改。
     
     
     成员函数的重载及参数缺省
     ·成员函数也可以重载
     ·成员函数可以带缺省参数。
  类：#include<iostream>
      using namespace std;
      class Location{
          private:
              int x,y;
          public:
              void init(int x=0,int y=0);
              void valuex(int vla){x=val;}
              int valuex(){return x;}
      }
    使用缺省参数要注意避免有函数重载时的二义性
    class Location{
        private:
            int x,y;
        public:
            void init(int x=0,int y=0);
          void valuex(int val=0){x=val;}
          int valuex(){return x;}
    };
    
   构造函数
       ·成员函数的一种
         ·名字与类名相同，可以有参数，不能有返回值（void也不行）
         ·作用是对对像进行初始化，如给成员变量付初值
         ·如果定义类时没写构造函数，则编译器生成一个默认的无参数的构造函数
             ·默认构造函数无参数，不做任何操作
         ·如果定义了构造函数，则编译器不生成默认的无参数的构造函数
         ·对像生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数
         ·一个类可以有多个构造函数
       为什么需要构造函数：
       （1）构造函数执行必要的初始化工作，有了构造函数，就不必再写初始化函数，也不用担心忘记调用初始化函数。
       （2）有时对象没被初始化就使用，会导致程序出错。
       可以有多个构造函数，参数的个数或类型不同。
       
       
   3.复制构造函数
       ·只有一个参数，即对同类对象的引用。
       ·形如X:X(x&)或X::X(const X &),二者选一，后者能以常量对象作为参数
       ·如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能。
       
       注意：不允许有形如X:X(X)的构造函数。构造函数的参数必须是引用。
     
     复制构造函数起作用的三种情况
     （1）当用一个对象去初始化同类的另一个对象时。
         Complex c2(c1);
         Complex c2=c1;//初始化语句，非赋值语句
     （2）如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用。
      class A
      {
          public:
          A(){};
          A(A&a){
              cout<<"Copy constructor called"<<endl;
          };
      }
      void Func(A al){}
      int main(){
             A a2;
             Func(a2);
             return 0;
      }
      //输出的结果是：Copy constructor called
        
     (3)如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用：   
    注意：对象间赋值并不导致复制构造函数被调用。   
        
    常量引用参数的使用
    void fun(CMyclass obj_){
        cout<<"fun"<<endl;
    }
    ——这样的函数，调用时生成形参会引发复制构造函数调用，开销比较大。
    ——所以可以考虑使用CMyclass&引用类型作为参数。
    ——如果希望确保实参的值在函数中不应被改变，那么可以加上const关键字。
    
    
 4.类型转换构造函数和析构函数
     什么是类型转换构造函数
       ·定义转换构造函数的目的是实现类型的自动转换。
       ·只有一个参数，而且不是复制构造函数的构造函数，一般就可以看作是转换构造函数。
       ·当需要的时候，编译系统会自动调用转换构造函数，建立一个无名对象（或临时变量）。
       
    什么是析构函数
        ·名字与类名相同，在前面加‘~’，没有参数和返回值，一个类最多只能有一个析构函数。
        ·析构函数对象消亡是即自动被调用。可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间等。
        ·如果定义类是没写析构函数，则编译器生成缺省析构函数。缺省析构函数什么也不做。
        ·如果定义了析构函数，则编译器不生成缺省析构函数。
        
    析构函数和运算符delete
    ·delete运算导致析构函数调用。
    Ctest*pTest;
    pTest=new Ctest;  //构造函数调用
    delete pTest;     //析构函数调用
    ------------------------------------------------------
    pTest=new Ctest[3];//构造函数调用3次
    delete [] pTest;   //析构函数调用3次
    ·若new一个对象数组，那么defelte释放时应该写[]。否则只有应该delete一个对象
    （调用一次析构函数）
    
    
    
    
    
    
    
        
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
       
