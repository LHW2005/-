第一周
    3.动态内存分配
        用new运算符实现动态内存分配
          ·第一种用法，分配一个变量；
          P=new T;
          T是任意类型名，P是类型为T*的指针。
          动态分配出一片大小为sizeof(T)字节的内存空间，并且将该内存的起始地址赋值给P。
          例如：
              int *pn;
              pn=new int;
              *pn=5;
          
          ·第二种用法，分配一个数组：
          P=new T[N];
          T:任意类型名
          P:类型为T*的指针
          N:要分配的数组元素的个数，可以是整型表达式
            动态分配出一片大小为N*sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P。
          示例：
              int*pn;
              int i=5;
              pn=new int[i*20];
              pn[0]=20;
              pn[100]=30;//编译没问题。运行时导致数组越界
              
          ·new运算符的返回值类型：
          new T;
          new T[n];
          这两个表达式返回值的类型都是T*
          int *p=new int;
          
          ·用delete运算符释放动态分配的内存
              ·用“new”动态分配的内存空间，一定要用“delete”运算符进行释放
              delete指针：//该指针必须指向new出来的空间
          int*p=new int;
          *p=5;
          delete p;
          delete p;  //导致异常，一片空间不能被delete多次
              ·用“delete”释放动态分配的数组，要在指针前加“[]”
              delete[]指针：//该指针必须指向new出来的数组
          int *p=new int[20];
          p[0]=1;
          delete []p;
          
    4.内联函数和重载函数
        内联函数
        ·函数调用是有时间开销的。如果函数本身只有几条语句，执行非常快，而且函数被
        反复执行很多次，相比之下调用函数所产生的这个开销就会显得比较大。
        ·为了减少函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语
        句时，是将整个函数的代码插入的到调用语句处，而不会产生调用函数的语句。
         
        在函数定义前面加“inline”关键字，即可定义内联函数
        inline int Max(int a,int b)
        {
            if(a>b) return a;
            return b;
        }
          
        函数重载
        ·一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载。
        ·以下三个函数是重载关系：
            int Max(double f1,double f2){}
            int Max(int n1,int n2){}
            int Max(int n1,int n2,int n3){}
        ·函数重载使得函数命名变得简单。
        ·编译器根据调用语句中的实参的个数和类型判断应该调用哪个函数。
        
        函数的缺省参数
        ·c++中，定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调
        用函数的时候，若相应位置不写参数，参数就是缺省值。
        示例:
            void func(int x1,int x2=2,int x3=3){}
            func(10);//等效于func(10,2,3)
            func(10,8);//等效于func(10,8,3)
            func(10,,8);//不行，只能最右边的连续若干个参数缺省
        
        ·函数参数可缺省的目的在于提高程序的可扩充性。
        ·即如果某个写好的函数要添加新的参数，而原先那些该调用该函数的语句，未必需要使用新增的参数，那么
        为了避免对原先那些函数调用语句的修改，就可以使用缺省参数。
        
        
    5.类和对象的基本概念（1）
    结构化程序设计
    ·c语言使用结构化程序设计：
        程序=数据结构+算法
    ·程序由全局变量以及众多相互调用的函数组成的。
    ·算法以函数的形式实现，用于对数据结构进行操作。
          
    结构化程序设计的不足
    ·结构化程序设计中，函数和其所操作的数据结构，没有直观的联系。
    ·随着程序规模的增加，程序逐渐难以理解，很难一下子看出来：
        ·某个数据结构到底有哪些函数可以对它进行操作？
        ·某个函数到底是用来操作那些数据结构的？
        ·任何两个数之间存在怎样的调用关系？
    ·结构化程序设计没有“封装”和“隐藏”的概念。
    要访问某个数据结构中的某个变量，就可以直接访问，那么当该变量的定义有改动的时候，
    就要把所有访问该变量的语句找出来修改，十分不利于程序的维护，扩充。
    ·难以查错，当某个数据结构的值不正确时，难以找出到底是那个函数导致的。
    
    ·重用：在编写某个程序时，发现其需要的某项功能，在现有的某个程序里已经有了相同或类似的实现，
    那么自然希望能够将那部分代码抽取出来，在新程序中使用。
    ·在结构化程序设计中， 随着程序规模的增大，由于程序大量函数，变量之间的关系错综复杂，要抽取
    部分代码，会变得十分困难。
          
    面向对象的程序设计
    ·面对对象的程序设计方法，能够较好解决上述问题。
    面向对象的程序=类+类+类+······+类
    ·设计程序的过程，就是设计类的过程
    
    ·面向对象的程序设计方法：
       ·将某类客观事物共同特点（属性）归纳出来，形成一个数据结构（可以用多个变量描述事物的属性）；
       ·将这类事物所能进行的行为也归纳出来，形成一个个函数，这些函数可以用来操作数据结构（这一步叫“抽象”）。
       ·然后，通过某种语法形式，将数据结构和操作数据结构的函数“捆绑”在一起，形成一个“类”，从而使得数据结构和
       操作该数据结构的算法呈现出显而易见的紧密关系，这就是“封装”。
       ·面向对象的程序设计具有“抽象”，“封装”，“继承”，“多态”四个基本特点。
          
   从客观事物抽象出类
   ·写一个程序，输入矩形的长和宽，输入面积和周长。
   ·比如对于“矩形”这种东西，要用一个类来表示，该如何做“抽象”呢？
   ·矩形的属性就是长和宽。因此需要两个变量，分别代表长和宽。
   ·一个矩形，可以有哪些行为呢（或可以对矩形进行哪些操作）？
       ·矩形可以有设置长和宽，算面积，和算周长这三种行为（当然也可以有其他行为）。
       ·这三种行为，可以各用一个函数来实现，他们都需要用到长和宽这两个变量。
          
   ·将长，宽变量和设置长，宽，求面积，以及求周长的三个函数“封装”在一起，就能形成一个“矩形类”。
   ·长，宽变量成为该“矩形类”的“成员变量”，三个函数成为该类的“成员函数”。成员变量和成员函数统称为类的成员。
   ·实际上，“类”看上去就像“带函数的结构”。
          
    ·通过类，可以定义变量。类定义出来的变量，也称为类的实例，也就是我们所说的“对象”。
    ·C++中，类的名字就是用户定义的类型的名字。可以像使用基本类型那样使用它。CRectangle就是一种用户自定义的类型。
    
    ·和结构变量一样，对象所占用的内存空间的大小，等于所有成员变量的大小之和。
    ·每个对象各有自己的存储空间。一个对象的某个成员变量被改变了，不会影响到另一个对象。
          
    对象之间的运算
        和结构变量一样，对象之间可以用“=”进行赋值，但是不能用“==”，“！=”，“>”，“<”，“>=”，“<=”进行比较，除非
        这些运算符经过了“重载”。
          
    使用类的成员变量和成员函数
        用法一：对象名.成员名
        CRectangle r1,r2;
        r1.w=5;
        r2.Init(5.4);
    ·lnit函数作用在r2上，即lnit函数执行期间访问的w和h是属于r2这个对象的，执行r2.lnit不会影响到r1。
        用法二:指针->成员名
        CRectangle r1,r2;
        CRectangle *p1=&r1;
        CRectangle *p1=&r2;
        p1->w=5;
        p2->Init(5,4);//lnit作用在p2指向的对象上
        
        用法三：引用名.成员名
            CRectangle r2;
            CRectangle &rr=r2;
            rr.w=5;
            rr.Init(5.4);//rr的值变了，r2的值也变
            
        
        
        
        
        
        
        
        
        
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
       
